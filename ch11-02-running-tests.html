<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 실행 방법 제어하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="테스트-실행-방법-제어하기"><a class="header" href="#테스트-실행-방법-제어하기">테스트 실행 방법 제어하기</a></h2>
<p><code>cargo run</code> 명령어가 코드를 컴파일하고 생성된 바이너리를 실행하는 것과 마찬가지로,
<code>cargo test</code> 명령어는 코드를 테스트 모드에서 컴파일하고 생성된 바이너리를 실행합니다.
<code>cargo test</code>에 의해 생성된 바이너리의 기본 동작은 모든 테스트를
병렬로 실행하고 테스트가 수행되는 동안 발생된 출력을 캡처하는
것으로, 출력이 표시되는 것을 막고 테스트 결과와 관련된 출력을
읽기 편하게 해 줍니다. 하지만 커맨드 라인 옵션을 지정하여 이러한
기본 동작을 변경할 수 있습니다.</p>
<p>명령어 옵션은 <code>cargo test</code>에 전달되는 것도 있고,
테스트 바이너리에 전달되는 것도 있습니다.
이 둘을 구분하기 위해 <code>cargo test</code>에 전달할 인수를 먼저 나열하고,
<code>--</code> 구분자 (separator) 를 쓰고, 그 뒤에 테스트 바이너리에게 전달할 인수를 나열합니다.
<code>cargo test --help</code> 명령어는 <code>cargo test</code> 명령어에 사용 가능한 옵션을 표시하고,
<code>cargo test -- --help</code> 명령어는 구분자 이후에 사용 가능한 옵션을 표시합니다.</p>
<h3 id="테스트를-병렬-혹은-순차적으로-실행하기"><a class="header" href="#테스트를-병렬-혹은-순차적으로-실행하기">테스트를 병렬 혹은 순차적으로 실행하기</a></h3>
<p>여러 테스트를 실행할 때는 기본적으로 스레드를 사용해 병렬 실행되는데,
이는 테스트를 더 빨리 끝내서 피드백을 더 빠르게 얻기 위함입니다.
여러 테스트가 동시에 실행되므로, 각 테스트가 공유 상태(공유 자원,
현재 작업 디렉터리, 환경 변수 등)를 갖거나 다른 테스트에 의존해서는
안 됩니다.</p>
<p>예시를 생각해 보죠. 각 테스트가 <em>test-output.txt</em> 파일을 생성하고
그 파일에 어떤 데이터를 작성하는 코드를 실행하도록 만들었습니다.
각 테스트는 파일의 데이터를 읽고, 파일이 특정 값을 포함하고 있는지 확인하며,
특정 값은 테스트마다 다릅니다.
여러 테스트가 동시에 실행되므로, 어떤 테스트가 파일에 작성하고 읽는 사이에
다른 테스트가 파일의 내용을 덮어쓸 수도 있습니다. 이 경우 방해받은 테스트는 실패할 겁니다.
코드에 문제가 있어서가 아니라, 병렬 실행되는 도중 방해받아서 말이죠.
한 가지 해결책은 각 테스트가 서로 다른 파일에 작성하도록 만드는 것일 테고,
다른 해결책은 테스트를 한 번에 하나씩 실행하는 것입니다.</p>
<p>테스트를 병렬로 실행하고 싶지 않거나,
사용할 스레드의 개수에 대한 미세 조정이 필요한 경우에는
<code>--test-threads</code> 플래그와 함께 테스트 바이너리에서 사용할 스레드 개수를 지정할 수 있습니다.
다음과 같이 사용합니다.</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>스레드 개수를 <code>1</code>로 설정하여 프로그램이
어떠한 병렬 처리도 사용하지 않도록 하였습니다.
스레드 하나만 사용해 테스트를 실행하면 병렬 실행에 비해 더 느려지겠지만,
서로 상태를 공유하는 테스트가 방해받을 일이 사라집니다.</p>
<h3 id="함수-출력-표시하기"><a class="header" href="#함수-출력-표시하기">함수 출력 표시하기</a></h3>
<p>기본적으로, 러스트 테스트 라이브러리는 성공한 테스트의 모든 표준 출력 (standard output) 을 캡처합니다.
테스트에서 <code>println!</code> 매크로를 호출해도, 해당 테스트가 성공하면
터미널에서 <code>println!</code>의 출력을 찾아볼 수 없습니다.
해당 테스트가 성공했다고 표시된 줄만 볼 수 있죠.
테스트가 실패하면 표준 출력으로 출력됐던 모든 내용이 실패 메시지 아래에 표시됩니다.</p>
<p>예제 11-10은 매개변수를 출력하고 10을 반환하는 단순한 함수와,
성공하는 테스트와 실패하는 테스트를 작성한 예시입니다.</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}</code></pre>
<p><span class="caption">예제 11-10: <code>println!</code>을 호출하는
함수 테스트</span></p>
<p><code>cargo test</code> 명령어를 실행하면 다음 결과가 나타납니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>성공한 테스트에서 출력했던
<code>I got the value 4</code>은  캡처되었으므로 찾아볼 수 없습니다.
실패한 테스트에서 출력한 <code>I got the value 8</code>는  테스트 실패 원인과 함께
테스트 출력 요약 절에 나타납니다.</p>
<p>성공한 테스트에서 출력한 내용도 보고 싶다면, 러스트에게 <code>--show-output</code> 옵션을
전달하여 성공한 테스트의 출력도 표시하도록 할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>예제 11-10의 테스트를 <code>--show-output</code> 플래그로 실행한 결과는
다음과 같습니다.</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="이름을-지정해-일부-테스트만-실행하기"><a class="header" href="#이름을-지정해-일부-테스트만-실행하기">이름을 지정해 일부 테스트만 실행하기</a></h3>
<p>간혹 테스트 모음을 전부 실행하는 데 시간이 오래 걸리기도 합니다. 코드의 특정한
부분에 대한 작업 중이라면 해당 부분의 코드에 관련된 테스트만 실행하고 싶을 수도
있습니다. <code>cargo test</code> 명령어에 테스트의 이름을 인수로 넘겨
어떤 테스트를 실행할지 선택할 수 있습니다.</p>
<p>일부 테스트만 실행하는 법을 알아보기 위해, 먼저 예제 11-11처럼
<code>add_two</code> 함수에 대한 세 가지 테스트를 작성하고 하나만 골라 실행해 보겠습니다.</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}</code></pre>
<p><span class="caption">예제 11-11: 세 가지 서로 다른 이름의
테스트</span></p>
<p>앞서 살펴본 것처럼, 테스트를 아무 인수도 없이 실행하면
모든 테스트가 병렬로 실행됩니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="테스트-하나만-실행하기"><a class="header" href="#테스트-하나만-실행하기">테스트 하나만 실행하기</a></h4>
<p><code>cargo test</code> 명령어에 테스트 함수 이름을 전달하여 해당 테스트만 실행할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p><code>one_hundred</code> 테스트만 실행되었습니다. 나머지 두 테스트는 이름이 맞지 않았습니다.
테스트 결과는 마지막 요약 라인에서 <code>2 filtered out</code>을 표시하여,
실행한 테스트 이외에도 다른 테스트가 존재함을 알려줍니다.</p>
<p>이 방법으로 테스트 이름을 여러 개 지정할 수는 없습니다. <code>cargo test</code> 명령어는 첫 번째 값만 사용합니다.
하지만 여러 테스트를 실행하는 방법이 없지는 않습니다.</p>
<h4 id="테스트를-필터링하여-여러-테스트-실행하기"><a class="header" href="#테스트를-필터링하여-여러-테스트-실행하기">테스트를 필터링하여 여러 테스트 실행하기</a></h4>
<p>테스트 이름의 일부만 지정하면 해당 값에 맞는 모든 테스트가 실행됩니다.
예를 들어, <code>cargo test add</code> 명령어를 실행하면 우리가 작성한 세 개의 테스트 중
<code>add</code>가 포함된 두 개가 실행됩니다.</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>이 명령어는 <code>add</code>가 이름에 포함된 모든 테스트를 실행하고,
<code>one_hundred</code> 테스트를 필터링했습니다.
테스트가 위치한 모듈도 테스트 이름의 일부로 나타나는 점을 기억해 두세요.
모듈 이름으로 필터링하면 해당 모듈 내 모든 테스트를 실행할 수 있습니다.</p>
<h3 id="특별-요청이-없다면-일부-테스트-무시하기"><a class="header" href="#특별-요청이-없다면-일부-테스트-무시하기">특별 요청이 없다면 일부 테스트 무시하기</a></h3>
<p>간혹 몇몇 특정 테스트는 실행하는 데 굉장히 오랜 시간이 걸려서,
<code>cargo test</code> 실행 시 이런 테스트는 제외하고 싶을 수도 있습니다.
그럴 때는 실행할 모든 테스트를 인수로 열거할 필요 없이
시간이 오래 걸리는 테스트에 <code>ignore</code> 속성을 어노테이션하면
됩니다.</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}</code></pre>
<p>제외할 테스트의 <code>#[test]</code> 다음 줄에 <code>#[ignore]</code> 줄을 추가했습니다.
이제 테스트를 실행하면 <code>it_works</code> 테스트는 실행되지만, <code>expensive_test</code> 테스트는 실행되지 않습니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><code>expensive_test</code> 테스트는 <code>ignored</code>로 표시되었습니다.
<code>cargo test -- --ignored</code> 명령어를 사용하면 무시된 테스트만 실행할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>실행할 테스트를 선별하여 <code>cargo test</code> 결과는 빨리 확인할 수 있습니다.
무시한 테스트의 결과를 확인해야 할 때가 되었고
그 결과를 기다릴 시간이 있다면, <code>cargo test -- --ignored</code> 명령어를
실행합니다. 무시되었건 말건 간에 모든 테스트를 실행하고 싶다면
<code>cargo test -- --include-ignored</code>를 실행할 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-01-writing-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-03-test-organization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-01-writing-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-03-test-organization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
