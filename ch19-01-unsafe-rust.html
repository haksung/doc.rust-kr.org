<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>안전하지 않은 러스트 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="안전하지-않은-러스트"><a class="header" href="#안전하지-않은-러스트">안전하지 않은 러스트</a></h2>
<p>지금까지 살펴본 모든 코드에는 컴파일 타임에 러스트의 메모리 안전 보장이
적용되었습니다. 그러나 러스트에는 이러한 메모리 안전 보장을 적용하지 않는
두 번째 언어가 숨겨져 있습니다: 이 언어는 <em>안전하지 않은 러스트 (unsafe Rust)</em>
라고 불리며 일반 러스트와 똑같이 작동하지만 추가 슈퍼파워를 제공합니다.</p>
<p>정적 분석은 본질적으로 보수적이기 때문에 안전하지 않은 러스트가 존재합니다.
컴파일러가 코드가 보증을 준수하는지 여부를 판단하려고 할 때, 일부 유효하지
않은 프로그램을 허용하는 것보다 일부 유효한 프로그램을 거부하는 것이 더 낫습니다.
코드가 <em>아마도</em> 괜찮을 수 있겠지만, 러스트 컴파일러는 확신할 수 있는 정보가
충분하지 않다면 코드를 거부할 것입니다. 이러한 경우, 안전하지 않은 코드를
사용하여 컴파일러에게 ‘날 믿어, 내가 뭘 하고 있는지 알고 있어’라고 말할 수
있습니다. 하지만, 안전하지 않은 러스트를 사용하는 것은 사용자의 책임하에 사용해야
한다는 점에 유의하시기를 바랍니다: 안전하지 않은 코드를 잘못 사용하면, 메모리
불안정성으로 인하여 널 포인터 역참조와 같은 문제가 발생할 수 있습니다.</p>
<p>러스트가 안전하지 않은 분신을 가진 또 다른 이유는 밑바탕이 되는 컴퓨터
하드웨어가 본질적으로 안전하지 않기 때문입니다. 러스트가 안전하지 않은
작업을 허용하지 않으면, 특정 작업을 수행할 수 없습니다. 러스트는 운영
체제와 직접 상호 작용하거나 자체 운영 체제를 작성하는 등의 저수준 시스템
프로그래밍을 할 수 있도록 허용해야 합니다. 저수준 시스템 프로그래밍 작업은
이 언어의 목표 중 하나입니다. 안전하지 않은 러스트로 할 수 있는 작업과
그 방법을 살펴봅시다.</p>
<h3 id="안전하지-않은-슈퍼파워"><a class="header" href="#안전하지-않은-슈퍼파워">안전하지 않은 슈퍼파워</a></h3>
<p>안전하지 않은 러스트로 전환하려면 <code>unsafe</code> 키워드를 사용한 다음 새 블록을
시작하여 안전하지 않은 코드를 집어넣으세요. 안전하지 않은 러스트에서는
<em>안전하지 않은 슈퍼파워</em>라고 부르는 다섯 가지 작업을 수행할 수 있습니다.
이러한 슈퍼파워에는 다음과 같은 기능이 포함됩니다:</p>
<ul>
<li>원시 포인터 (raw pointer) 역참조하기</li>
<li>안전하지 않은 함수 혹은 메서드 호출하기</li>
<li>가변 정적 변수에 접근하기 및 수정하기</li>
<li>안전하지 않은 트레이트 구현하기</li>
<li><code>union</code>의 필드 접근하기</li>
</ul>
<p><code>unsafe</code>가 대여 검사기를 끄거나 러스트의 다른 안전성 검사를 비활성화하지
않는다는 점을 이해하는 것이 중요합니다: 안전하지 않은 코드에서 참조를 사용하면,
검사는 여전히 이루어집니다. <code>unsafe</code> 키워드는 컴파일러가 메모리 안전성을 검사하지
않는 위의 다섯 가지 기능 허용만 제공할 뿐입니다. 안전하지 않은 블록 내부에서도
여전히 어느 정도의 안전성을 확보할 수 있습니다.</p>
<p>더불어 <code>unsafe</code>라는 것은 블록 내부의 코드가 반드시 위험하거나
메모리 안전에 문제가 있다는 것을 의미하지 않습니다: 그 의도는
<code>unsafe</code> 블록 내부의 코드가 유효한 방식으로 메모리에 접근하도록
프로그래머가 보장해야 한다는 것입니다.</p>
<p>사람은 누구나 실수를 할 수 있고 실수는 일어나기 마련이지만, 이 다섯 가지
안전하지 않은 연산을 <code>unsafe</code>로 주석 처리된 블록 안에 넣도록 하면
메모리 안전과 관련된 모든 에러는 <code>unsafe</code> 블록 안에 있을 수밖에
없음을 알 수 있습니다. <code>unsafe</code> 블록을 작게 유지하세요; 나중에 메모리
버그를 조사할 때 유용하게 사용할 수 있습니다.</p>
<p>안전하지 않은 코드를 최대한 분리하려면 안전하지 않은 코드를 안전한
추상화 안에 넣고 안전한 API를 제공하는 것이 가장 좋으며, 이는 이 장의
뒷부분에서 안전하지 않은 함수와 메서드를 살펴볼 때 설명할 것입니다.
표준 라이브러리의 일부는 감사를 거친 안전하지 않은 코드 위에 안전한
추상화로 구현되어 있습니다. 안전하지 않은 코드를 안전 추상화로 감싸면
<code>unsafe</code> 코드가 구현된 기능을 사용하려는 모든 곳에서 <code>unsafe</code>라고
쓰는 것을 방지할 수 있는데, 이는 안전 추상화를 사용하면 안전하기
때문입니다.</p>
<p>다섯 개의 안전하지 않은 슈퍼파워를 차례대로 살펴봅시다. 또한 안전하지 않은 코드에
안전한 인터페이스를 제공하는 추상화도 일부 살펴보겠습니다.</p>
<h3 id="원시-포인터-역참조하기"><a class="header" href="#원시-포인터-역참조하기">원시 포인터 역참조하기</a></h3>
<p>4장의 <a href="ch04-02-references-and-borrowing.html#dangling-references">‘댕글링 참조’</a><!-- ignore -->절에서
컴파일러가 참조가 항상 유효하다는 것을 보장한다고 언급했습니다.
안전하지 않은 러스트에는 참조와 유사한 <em>원시 포인터 (raw pointer)</em> 라는
두 가지 새로운 타입이 있습니다. 참조자와 마찬가지로 원시 포인터는
불변 또는 가변이며 각각 <code>*const T</code>와 <code>*mut T</code>로 작성됩니다.
별표는 역참조 연산자가 아니라 타입 이름의 일부입니다. 원시 포인터의
맥락에서 <em>불변</em>이란 포인터가 역참조된 후에 직접 할당할 수 없음을
의미합니다.</p>
<p>참조자와 스마트 포인터와는 다르게 원시 포인터는 다음과 같은 특징이 있습니다:</p>
<ul>
<li>원시 포인터는 대여 규칙을 무시할 수 있으며, 같은 위치에 대해 불변과 가변 포인터를
동시에 가질 수 있거나 여러 개의 가변 포인터를 가질 수 있습니다.</li>
<li>원시 포인터는 유효한 메모리를 가리키는 것을 보장받지 못합니다.</li>
<li>원시 포인터는 널 (null) 이 될 수 있습니다.</li>
<li>원시 포인터는 자동 메모리 정리를 구현하지 않습니다.</li>
</ul>
<p>러스트가 이러한 보증을 적용하지 않도록 선택하면, 이러한 보장된 안전성을
포기하는 대신 러스트의 보증이 적용되지 않는 다른 언어 또는 하드웨어와
인터페이싱할 수 있는 기능이나 더 나은 성능을 얻을 수 있습니다.</p>
<p>예제 19-1은 참조자로부터 불변과 가변 원시 포인터를 만드는 방법을
보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-1: 참조자로부터 원시 포인터 생성하기</span></p>
<p>이 코드에 <code>unsafe</code> 키워드를 포함시키지 않았음을 주목하세요. 원시 포인터는
안전한 코드에서 생성될 수 있습니다; 잠시 후 보게 될 것처럼, 그저 안전하지
않은 블록 밖에서 원시 포인터를 역참조하는 것이 불가능할 뿐입니다.</p>
<p><code>as</code>를 사용하여 불변 참조자와 가변 참조자를 해당 원시 포인터
타입으로 캐스팅하여 원시 포인터를 생성했습니다. 유효성이 보장된
참조자로부터 직접 생성했기 때문에 이러한 특정 원시 포인터가
유효하다는 것을 알지만, 모든 원시 포인터에 대해 이러한 가정을
할 수는 없습니다.</p>
<p>이를 증명하기 위해 다음으로 유효성을 확신할 수 없는 원시 포인터를
생성해 보겠습니다. 예제 19-2는 메모리의 임의 위치에 대한 원시
포인터를 생성하는 방법을 보여줍니다. 임의의 메모리를 사용하려고
하면 해당 주소에 데이터가 있을 수도 있고 없을 수도 있으며, 컴파일러가
코드를 최적화하여 메모리 접근이 없도록 할 수도 있고, 세그먼트 에러로
인해 프로그램에서 에러가 발생할 수도 있습니다. 일반적으로 이런 코드를
작성할 좋은 이유는 없지만, 가능은 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-2: 임의 메모리 주소를 가리키는 원시
포인터 생성하기</span></p>
<p>안전한 코드에서 원시 포인터를 생성할 수는 있지만, 원시 포인터를 <em>역참조</em>하여
가리키는 데이터를 읽을 수는 없다는 점을 상기하세요. 예제 19-3에서는 원시 포인터에
<code>unsafe</code> 블록이 필요한 역참조 연산자 <code>*</code>를 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-3: <code>unsafe</code> 블록 내에서 원시 포인터
역참조하기</span></p>
<p>포인터를 생성하는 것은 아무런 해를 끼치지 않습니다; 포인터가 가리키는 값에 접근하려고
할 때 유효하지 않은 값을 처리해야 할 수도 있는 경우가 문제를 일으키는 것입니다.</p>
<p>또한 예제 19-1과 19-3에서는 <code>*const i32</code>와 <code>*mut i32</code> 원시 포인터를
생성했는데, 이 두 포인터는 모두 <code>num</code>이 저장된 동일한 메모리 위치를
가리키는 것을 주의하세요. 대신 <code>num</code>에 대한 불변 참조자와 가변 참조자를
생성하려고 시도했다면 코드가 컴파일되지 않았을 것인데, 이는 러스트의 소유권
규칙에 따르면 가변 참조자와 불변 참조자를 동시에 허용하지 않기 때문입니다.
원시 포인터를 사용하면 같은 위치에 대한 가변 포인터와 불변 포인터를 생성하고
가변 포인터를 통해 데이터를 변경하여 잠재적으로 데이터 경합을 일으킬 수
있습니다. 조심하세요!</p>
<p>이런 위험성이 있는데도 왜 원시 포인터를 사용하게 될까요? 한 가지 주요
사용 사례는 다음 절
<a href="#calling-an-unsafe-function-or-method">‘안전하지 않은 함수 또는 메서드 호출하기’</a><!-- ignore -->
에서 볼 수 있듯이 C 코드와 상호작용할 때입니다.
또 다른 경우는 대여 검사기가 이해하지 못하는 안전한 추상화를 구축할 때입니다.
안전하지 않은 함수를 소개한 다음 안전하지 않은 코드를 사용하는 안전한 추상화의
예를 살펴보겠습니다.</p>
<h3 id="안전하지-않은-함수-또는-메서드-호출하기"><a class="header" href="#안전하지-않은-함수-또는-메서드-호출하기">안전하지 않은 함수 또는 메서드 호출하기</a></h3>
<p>안전하지 않은 블록에서 수행할 수 있는 두 번째 유형의 작업은
안전하지 않은 함수를 호출하는 것입니다. 안전하지 않은 함수와
메서드는 일반 함수나 메서드와 똑같아 보이지만, 정의 앞부분에
<code>unsafe</code>가 추가됩니다. 이 컨텍스트에서 <code>unsafe</code> 키워드는 이 함수를
호출할 때 지켜야 할 요구사항이 있음을 나타내는데, 이는 러스트가
이러한 요구사항을 충족했다고 보장할 수 없기 때문입니다. 안전하지
않은 함수를 <code>unsafe</code> 블록 내에서 호출한다는 것은 이 함수의 문서를
읽었으며 함수의 계약서를 준수할 책임이 있음을 의미합니다.</p>
<p>아래는 본문에서 아무 일도 하지 않는 <code>dangerous</code>라는 이름의 안전하지 않은
함수입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p><code>dangerous</code> 함수는 반드시 분리된 <code>unsafe</code> 블록 내에서 호출되어야 합니다. <code>unsafe</code>
블록 없이 <code>dangerous</code>를 호출하려고 시도하면 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p><code>unsafe</code> 블록을 사용하는 것은 해당 함수의 설명서를 읽었고, 해당
함수를 올바르게 사용하는 방법을 이해했으며, 해당 함수의 계약서를
이행하고 있음을 확인한다고 러스트에게 단언하는 꼴입니다.</p>
<p>안전하지 않은 함수의 본문은 사실상 <code>unsafe</code> 블록이므로, 안전하지 않은 함수
내에서 안전하지 않은 연산을 수행하기 위해 또 <code>unsafe</code> 블록을 추가할
필요는 없습니다.</p>
<h4 id="안전하지-않은-코드를-감싸는-안전한-추상화-만들기"><a class="header" href="#안전하지-않은-코드를-감싸는-안전한-추상화-만들기">안전하지 않은 코드를 감싸는 안전한 추상화 만들기</a></h4>
<p>함수에 안전하지 않은 코드가 포함되어 있다고 해서 전체 함수를 안전하지 않은
것으로 표시할 필요는 없습니다. 사실 안전하지 않은 코드를 안전한 함수로 감싸는
것은 일반적인 추상화입니다. 예를 들어, 안전하지 않은 코드가 약간 필요한 표준
라이브러리의 <code>split_at_mut</code> 함수를 살펴봅시다. 이를 어떻게 구현할 수 있는지
살펴보겠습니다. 이 안전한 메서드는 가변 슬라이스에 대해 정의됩니다: 하나의
슬라이스를 받아 인수로 주어진 인덱스에서 슬라이스를 분할하여 두 개로 만듭니다.
예제 19-4는 <code>split_at_mut</code>을 사용하는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-4: 안전한 <code>split_at_mut</code> 함수
사용하기</span></p>
<p>안전한 러스트만 사용하여 이 함수를 구현할 수는 없습니다. 예제 19-5처럼 시도해 볼 수 있지만
컴파일되지 않을 것입니다. 간단하게 하기 위해 <code>split_at_mut</code>를
메서드가 아닌 함수로 구현하고 제네릭 타입 <code>T</code> 대신 <code>i32</code> 값의 슬라이스에
대해서 만으로 구현하겠습니다.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<p><span class="caption">예제 19-5: 안전한 러스트만 사용하여 <code>split_at_mut</code>
구현 시도하기</span></p>
<p>이 함수는 먼저 슬라이스의 전체 길이를 얻습니다. 그런 다음 매개변수로
주어진 인덱스가 슬라이스의 길이보다 작거나 같은지 확인하는 것으로
슬라이스 내에 있음을 단언합니다. 이 단언문은 슬라이스를 분할하기 위해
길이보다 큰 인덱스를 전달하면 해당 인덱스를 사용하기 전에 함수가 패닉을
일으키리란 것을 의미합니다.</p>
<p>그다음 두 개의 가변 슬라이스를 튜플 안에 넣어 반환합니다: 하나는 원본 슬라이스의
시작부터 <code>mid</code> 인덱스까지의 슬라이스이고, 다른 하나는 <code>mid</code> 인덱스부터 원본 슬라이스의
끝까지의 슬라이스입니다.</p>
<p>예제 19-5의 코드를 컴파일 시도하면 아래와 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>러스트의 대여 검사기는 슬라이스의 서로 다른 부분을 빌린다는 것을 이해할 수
없습니다; 러스트는 그저 동일한 슬라이스를 두 번 빌린다는 것만 알고 있습니다.
슬라이스의 서로 다른 부분을 빌리는 것은 두 슬라이스가 겹치지 않기 때문에
기본적으로 괜찮지만, 러스트는 이를 알아차릴 만큼 똑똑하지 못합니다. 우리는 코드가
괜찮다는 것을 알지만 러스트는 그렇지 않다면, 안전하지 않은 코드를 이용할 시간입니다.</p>
<p>예제 19-6은 <code>split_at_mut</code>의 구현체를 작동시키기 위해 <code>unsafe</code> 블록,
원시 포인터, 그리고 안전하지 않은 함수 호출을 사용하는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-6: <code>split_at_mut</code> 함수의 구현체에서
안전하지 않은 코드 사용하기</span></p>
<p>4장의 <a href="ch04-03-slices.html#the-slice-type">‘슬라이스 타입’</a><!-- ignore --> 절에서
슬라이스란 데이터를 가리키는 포인터와 슬라이스의 길이인 것을 기억하세요.
<code>len</code> 메서드를 사용하여 슬라이스의 길이를 얻고 <code>as_mut_ptr</code> 메서드를
사용하여 슬라이스의 원시 포인터를 얻었습니다. 이번 경우에는 <code>i32</code> 값에
대한 가변 슬라이스이므로, <code>as_mut_ptr</code>는 <code>*mut i32</code> 타입의 원시 포인터를
반환하며, 이 포인터는 <code>ptr</code> 변수에 저장됩니다.</p>
<p><code>mid</code> 인덱스가 슬라이스 내에 있다는 단언은 유지합니다. 그다음 안전하지
않은 코드에 도달합니다: <code>slice::from_raw_parts_mut</code> 함수는 원시 포인터와
길이를 받아 슬라이스를 생성합니다. 이 함수를 사용하여 <code>ptr</code>에서 시작하고
<code>mid</code> 길이의 아이템을 가진 슬라이스를 만듭니다. 그런 다음 <code>ptr</code>에서 <code>mid</code>를
인수로 <code>add</code> 메서드를 호출하여 <code>mid</code>에서 시작하는 원시 포인터를 가져오고,
이 포인터와 <code>mid</code> 이후의 나머지 아이템 개수를 길이로 사용하여 슬라이스를
생성합니다.</p>
<p><code>slice::from_raw_parts_mut</code> 함수는 원시 포인터를 얻어와서 이 포인터의
유효성을 신뢰해야 하기 때문에 안전하지 않습니다. 원시 포인터에 대한 <code>add</code>
메서드도 오프셋 위치가 유효한 포인터임을 신뢰해야 하기 때문에 안전하지
않습니다. 따라서 <code>slice::from_raw_parts_mut</code>와 <code>add</code>를 호출할 수
있도록 주위에 <code>unsafe</code> 블록을 넣어야 했습니다. 코드를 살펴보고 <code>mid</code>가
<code>len</code>보다 작거나 같아야 한다는 단언문을 추가하면 <code>unsafe</code> 블록 내에서
사용되는 모든 원시 포인터가 슬라이스 내의 데이터에 대한 유효한 포인터가
될 것임을 알 수 있습니다. 이는 <code>unsafe</code>에 대한 받아들일 만하고 적절한
사용입니다.</p>
<p>결과인 <code>split_at_mut</code> 함수를 <code>unsafe</code>로 표시할 필요는 없으며,
안전한 러스트에서 이 함수를 호출할 수 있다는 점에 유의하세요.
이 함수는 접근할 수 있는 데이터에서 유효한 포인터만 생성하기 때문에,
<code>unsafe</code> 코드를 안전한 방식으로 사용하는 함수의 구현을 통해 안전하지
않은 코드에 대한 안전한 추상화를 만든 것이 되었습니다.</p>
<p>반면 예제 19-7의 <code>slice::from_raw_parts_mut</code> 사용은 슬라이스가 사용될 때
크래시가 발생하기 쉽습니다. 이 코드는 임의의 메모리 위치를 가져와서 10,000개의
아이템을 가진 슬라이스를 생성합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-7: 임의의 메모리 위치로부터 슬라이스
생성하기</span></p>
<p>이 임의 위치에 있는 메모리를 소유하지 않고, 이 코드가 생성하는 슬라이스가
유효한 <code>i32</code> 값들을 포함하고 있는지에 대한 보장이 없습니다. <code>values</code>를 마치
유효한 슬라이스인 것처럼 사용하려고 하면 정의되지 않은 동작이 발생합니다.</p>
<h4 id="extern-함수를-사용하여-외부-코드-호출하기"><a class="header" href="#extern-함수를-사용하여-외부-코드-호출하기"><code>extern</code> 함수를 사용하여 외부 코드 호출하기</a></h4>
<p>종종 러스트 코드는 다른 언어로 작성된 코드와 상호작용해야 할 필요가
있습니다. 이를 위해 러스트에는 <em>외래 함수 인터페이스 (Foreign Function Interface, FFI)</em> 의
생성과 사용을 용이하게 하는 키워드 <code>extern</code>이 있습니다. FFI는 프로그래밍
언어가 함수를 정의하고 다른 (외래) 프로그래밍 언어가 해당 함수를 호출할 수
있도록 하는 방법입니다.</p>
<p>예제 19-8은 C 표준 라이브러리의 <code>abs</code> 함수와의 통합을 설정하는 방법을
보여줍니다. <code>extern</code> 블록 내에 선언된 함수는 러스트 코드에서 호출되기에
항상 안전하지 않습니다. 그 이유는 다른 언어가 러스트의 규칙과 보증을
적용하지 않고, 러스트가 이를 확인할 수 없어서 프로그래머에게 안전을
보장할 책임이 있기 때문입니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<p><span class="caption">예제 19-8: 다른 언어에 정의된 <code>extern</code> 함수의
선언 및 호출</span></p>
<p><code>extern "C"</code> 블록에는 호출하려는 다른 언어의 외부 함수의
이름과 시그니처를 나열합니다. <code>"C"</code> 부분은 외부 함수가 사용하는
<em>ABI (application binary interface)</em> 를 정의합니다: ABI는
어셈블리 수준에서 함수를 호출하는 방법을 정의합니다. <code>"C"</code> ABI는
가장 일반적이며 C 프로그래밍 언어의 ABI를 따릅니다.</p>
<blockquote>
<h4 id="다른-언어에서-러스트-함수-호출하기"><a class="header" href="#다른-언어에서-러스트-함수-호출하기">다른 언어에서 러스트 함수 호출하기</a></h4>
<p>또한 <code>extern</code>을 사용하여 다른 언어에서 러스트 함수를 호출할 수 있는
인터페이스를 만들 수도 있습니다. 전체 <code>extern</code> 블록을 생성하는 대신,
<code>extern</code> 키워드를 추가하고 관련 함수에 대한 <code>fn</code> 키워드 바로 앞에
사용할 ABI를 지정합니다. 또한 <code>#[no_mangle]</code> 어노테이션을 추가하여
러스트 컴파일러가 이 함수의 이름을 맹글링하지 않도록 지시해야 합니다.
<em>맹글링 (mangling)</em> 이란 우리가 함수에 부여한 이름을 컴파일러가 컴파일
과정의 다른 부분에서 사용할 수 있도록 더 많은 정보를 포함하지만 사람이
읽기엔 불편한 다른 이름으로 변경하는 것을 말합니다. 모든 프로그래밍 언어
컴파일러는 이름을 조금씩 다르게 변경하므로, 다른 언어에서 러스트 함수의 이름을
불리도록 하려면 러스트 컴파일러의 이름 맹글링 기능을 비활성화해야 합니다.</p>
<p>다음 예제에서는 <code>call_from_c</code> 함수를 공유 라이브러리로 컴파일하고 C에서
링크한 후, C 코드에서 함수에 접근할 수 있도록 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p>이러한 <code>extern</code>의 사용에는 <code>unsafe</code>가 필요 없습니다.</p>
</blockquote>
<h3 id="가변-정적-변수의-접근-혹은-수정하기"><a class="header" href="#가변-정적-변수의-접근-혹은-수정하기">가변 정적 변수의 접근 혹은 수정하기</a></h3>
<p>이 책에서 아직 <em>전역 변수 (global variable)</em> 에 대해 언급하지 않았는데, 러스트는
이를 지원하지만 러스트의 소유권 규칙과 문제가 발생할 수 있습니다. 두 스레드가
동일한 가변 전역 변수에 접근하고 있다면 데이터 경합이 발생할 수 있습니다.</p>
<p>러스트에서 전역 변수는 <em>정적 (static)</em> 변수라고 부릅니다. 예제 19-9는
문자열 슬라이스를 값으로 사용하는 정적 변수의 선언과 사용례를
보여줍니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}</code></pre></pre>
<p><span class="caption">예제 19-9: 불변 정적 변수의 정의 및
사용</span></p>
<p>정적 변수는 3장의
<a href="ch03-01-variables-and-mutability.html#constants">‘상수’</a><!-- ignore -->절에서
다루었던 상수와 유사합니다. 정적 변수의 이름은 관례적으로
<code>SCREAMING_SNAKE_CASE</code>를 사용합니다. 정적 변수는 <code>'static</code>
라이프타임을 가진 참조자만 저장할 수 있으며, 이는 러스트
컴파일러가 라이프타임을 알아낼 수 있으므로 명시적으로 어노테이션할
필요가 없음을 의미합니다. 불변 정적 변수에 접근하는 것은
안전합니다.</p>
<p>상수와 불변 정적 변수의 미묘한 차이점은 정적 변수의 값이
메모리에 고정된 주소를 갖는다는 점입니다. 값을 사용하면
항상 동일한 데이터에 접근할 수 있습니다. 반면 상수는 사용할
때마다 데이터가 복제될 수 있습니다. 또 다른 차이점은 정적 변수가
가변일 수 있다는 점입니다. 가변 정적 변수에 접근하고 수정하는
것은 <em>안전하지 않습니다</em>. 예제 19-10은 <code>COUNTER</code>라는 가변 정적
변수를 선언하고, 접근하고, 수정하는 방법을 보여줍니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}</code></pre></pre>
<p><span class="caption">예제 19-10: 가변 정적 변수를 읽거나 쓰는 것은
안전하지 않습니다</span></p>
<p>일반적인 변수와 마찬가지로 <code>mut</code> 키워드를 사용하여 가변성을 지정합니다.
<code>COUNTER</code>를 읽거나 쓰는 모든 코드는 <code>unsafe</code> 블록 내에 있어야 합니다.
이 코드는 싱글스레드이기 때문에 예상대로 <code>COUNTER: 3</code>을 컴파일하고
출력합니다. 여러 스레드가 <code>COUNTER</code>에 접근하면 데이터 경합이 발생할
수 있습니다.</p>
<p>전역적으로 접근할 수 있는 가변 데이터의 경우 데이터 경합이 발생하지 않도록
보장하기가 어려우며, 이것이 러스트가 가변 정적 변수를 안전하지 않은 것으로
간주하는 이유입니다. 가능하면 16장에서 설명한 동시성 기술과 스레드-안전한
스마트 포인터를 사용해 컴파일러가 다른 스레드에서 접근한 데이터에 안전하게
접근하는지 검사하도록 하는 편이 좋습니다.</p>
<h3 id="안전하지-않은-트레이트-구현하기"><a class="header" href="#안전하지-않은-트레이트-구현하기">안전하지 않은 트레이트 구현하기</a></h3>
<p><code>unsafe</code>를 사용하여 안전하지 않은 트레이트를 구현할 수 있습니다. 메서드 중
하나 이상에 컴파일러가 확인할 수 없는 불변성 (invariant) 이 있는 경우
그 트레이트는 안전하지 않습니다. 예제 19-11에 표시된 것처럼 <code>trait</code>
앞에 <code>unsafe</code> 키워드를 추가하고 그 트레이트의 구현체도 <code>unsafe</code>로 표시함으로써
트레이트가 <code>unsafe</code>하다고 선언할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">unsafe trait Foo {
    // 여기에 메소드가 작성됩니다
}

unsafe impl Foo for i32 {
    // 여기에 메소드 구현이 작성됩니다
}

fn main() {}</code></pre></pre>
<p><span class="caption">예제 19-11: 안전하지 않은 트레이트의
정의 및 구현</span></p>
<p><code>unsafe impl</code>을 사용하면 컴파일러가 확인할 수 없는 불변성은 우리가
지키겠다는 약속을 하는 것입니다.</p>
<p>예를 들어, 16장의
<a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">‘<code>Sync</code>와 <code>Send</code> 트레이트를 이용한 확장 가능한 동시성’</a><!-- ignore -->절에서
설명한 <code>Sync</code> 및 <code>Send</code> 마커 트레이트를 상기해 봅시다: 타입이
<code>Send</code> 및 <code>Sync</code> 타입으로만 구성된 경우에는 컴파일러가
이러한 트레이트를 자동으로 구현합니다. 원시 포인터와 같이
<code>Send</code> 혹은 <code>Sync</code>가 아닌 타입을 포함하고 있는 타입을 구현하고,
해당 타입을 <code>Send</code> 또는 <code>Sync</code>로 표시하려면 <code>unsafe</code>를 사용해야
합니다. 러스트는 해당 타입이 스레드 간에 안전하게 전송되거나
여러 스레드에서 접근할 수 있다는 보장을 준수하는지 확인할 수 없습니다;
따라서 이러한 검사를 수동으로 수행하고 <code>unsafe</code>로 표시해야 합니다.</p>
<h3 id="유니온-필드에-접근하기"><a class="header" href="#유니온-필드에-접근하기">유니온 필드에 접근하기</a></h3>
<p><code>unsafe</code> 경우에만 작동하는 마지막 작업은 <em>유니온 (union)</em> 의 필드에 접근하는
것입니다. <code>union</code>은 <code>struct</code>와 유사하지만, 특정 인스턴스에서 한 번에 하나의
선언된 필드만 사용됩니다. 유니온은 주로 C 코드의 유니온과 상호작용하는데
사용됩니다. 러스트는 현재 유니온 인스턴스에 저장된 데이터의 타입을 보장할
수 없기 때문에, 유니온 필드에 접근하는 것은 안전하지 않습니다. 유니온에 대한
자세한 내용은 <a href="https://doc.rust-lang.org/reference/items/unions.html">러스트 참고 자료 문서</a>에서 확인할 수 있습니다.</p>
<h3 id="unsafe-코드를-사용하는-경우"><a class="header" href="#unsafe-코드를-사용하는-경우"><code>unsafe</code> 코드를 사용하는 경우</a></h3>
<p><code>unsafe</code>을 사용하여 방금 설명한 다섯 가지 동작 (슈퍼파워) 중 하나를 수행하는 것은 잘못된
것도 아니고, 심지어 눈살을 찌푸릴 일도 아닙니다. 하지만 컴파일러가 메모리 안전성을
유지할 수 없기 때문에, <code>unsafe</code> 코드를 올바르게 만드는 것은 더 까다롭습니다.
<code>unsafe</code> 코드를 사용해야 할 이유가 있다면 그렇게 할 수 있으며, 명시적인 <code>unsafe</code>
어노테이션을 통해 문제가 발생했을 때 문제의 원인을 더 쉽게 추적할 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
