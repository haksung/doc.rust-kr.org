<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>문자열에 UTF-8 텍스트 저장하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="문자열에-utf-8-텍스트-저장하기"><a class="header" href="#문자열에-utf-8-텍스트-저장하기">문자열에 UTF-8 텍스트 저장하기</a></h2>
<p>4장에서도 문자열을 다뤄봤지만, 이번에는 좀 더 깊이 살펴보겠습니다. 갓
입문한 러스타시안은 보통 세 가지 이유의 조합에 의해 문자열 부분에서
막힙니다: 발생할 수 있는 에러를 최대한 표시하는 러스트의 성향, 많은
프로그래머의 예상보다 문자열이 복잡한 자료구조라는 점, 그리고 UTF-8이
그 이유입니다. 이 때문에 다른 언어를 사용하다 넘어오면 러스트의
문자열은 어려워 보이죠.</p>
<p>문자열이 컬렉션 장에 있는 이유는 문자열이 바이트의 컬렉션으로
구현되어 있고, 이 바이트들을 텍스트로 통역할 때 유용한 기능을
제공하는 여러 메서드들을 구현해 두었기 때문입니다. 이번 절에서는
생성, 업데이트, 값 읽기와 같은 모든 컬렉션 타입이 가지고 있는,
<code>String</code>에서의 연산에 대해 이야기해 보겠습니다. 또한
<code>String</code>을 다른 컬렉션들과 다르게 만드는 부분, 즉 사람과
컴퓨터가 <code>String</code> 데이터를 통역하는 방식 간의 차이로 인해
생기는 <code>String</code> 인덱싱의 복잡함을 논의해 보겠습니다.</p>
<h3 id="문자열이-뭔가요"><a class="header" href="#문자열이-뭔가요">문자열이 뭔가요?</a></h3>
<p>먼저 <em>문자열 (string)</em> 이라는 용어가 정확히 무엇을 뜻하는 것인지 정의해 보겠습니다.
러스트 핵심 기능 중 문자열 타입은 오직 하나뿐이며,
일반적으로 참조형인 <code>&amp;str</code>형태로 사용하는 문자열 슬라이스 <code>str</code>입니다.
4장에서는 <em>문자열 슬라이스</em>에 대해 얘기했고, 이는 UTF-8으로 인코딩되어
다른 어딘가에 저장된 문자열 데이터의 참조자입니다. 예를 들어, 문자열 리터럴은
프로그램의 바이너리 결과물 안에 저장되어 있으며, 그러므로 문자열 슬라이스입니다.</p>
<p><code>String</code> 타입은 언어의 핵심 기능에 구현된 것이 아니고 러스트의 표준
라이브러리를 통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고,
UTF-8으로 인코딩된 문자열 타입입니다. 러스타시안들이 ‘문자열’에 대해 이야기할
때는 보통 <code>String</code>과 문자열 슬라이스 <code>&amp;str</code> 타입 둘 중 무언가를 이야기하는
것이지, 특정한 하나를 뜻하는 것은 아닙니다. 이번 절은 대부분 <code>String</code>에 관한
것이지만, 두 타입 모두 러스트 표준 라이브러리에서 매우 많이 사용되며 <code>String</code>과
문자열 슬라이스 모두 UTF-8으로 인코딩되어 있습니다.</p>
<h3 id="새로운-문자열-생성하기"><a class="header" href="#새로운-문자열-생성하기">새로운 문자열 생성하기</a></h3>
<p><code>Vec&lt;T&gt;</code>에서 쓸 수 있는 연산 다수가 <code>String</code>에서도 똑같이 쓸 수
있는데, 이는 <code>String</code>이 실제로 바이트 벡터에 더하여 몇 가지 보장,
제한, 기능들을 추가한 래퍼 (wrapper) 로 구현되어 있기 때문입니다.
<code>Vec&lt;T&gt;</code>와 <code>String</code>이 같은 방식으로 동작한다는 함수의 예시로 예제 8-11과
같이 새 인스턴스를 생성하는 <code>new</code> 함수가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-11: 비어있는 새로운 <code>String</code> 생성하기</span></p>
<p>이 라인은 어떤 데이터를 담을 수 있는 <code>s</code>라는 빈 문자열을 만들어 줍니다.
종종 시작 지점에서 저장해 둘 문자열의 초깃값을 가지고 있을 것입니다.
그럴 때는 <code>to_string</code> 메서드를 이용하는데, 이는 <code>Display</code> 트레이트가 구현된
어떤 타입이든 사용 가능하며, 문자열 리터럴도 이 트레이트를 구현하고 있습니다.
예제 8-12에서 두 가지 예제를 보여주고 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // 이 메서드는 리터럴에서도 바로 작동합니다:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-12: <code>to_string</code> 메서드를 사용하여 문자열
리터럴로부터 <code>String</code> 생성하기</span></p>
<p>이 코드는 <code>initial contents</code>를 담고 있는 문자열을 생성합니다.</p>
<p>또한 문자열 리터럴로부터 <code>String</code>을 생성하기 위해서 <code>String::from</code> 함수를
이용할 수도 있습니다. 예제 8-13의 코드는 <code>to_string</code>을 사용하는 예제 8-12의
코드와 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-13: <code>String::from</code> 함수를 사용하여 문자열
리터럴로부터 <code>String</code> 생성하기</span></p>
<p>문자열이 매우 다양한 용도로 사용되기 때문에, 문자열에 다양한 제네릭
API들을 사용할 수 있으며, 이를 통해 다양한 옵션들을 제공할 수 있습니다.
몇몇은 중복되어 보일 수 있지만, 다 사용할 곳이 있습니다! 지금의 경우
<code>String::from</code>과 <code>to_string</code>은 동일한 작업을 수행하므로, 따라서 어떤 것을
사용하는가는 스타일과 가독성의 문제입니다.</p>
<p>문자열이 UTF-8으로 인코딩되었음을 기억하세요. 즉, 아래의 예제 8-14처럼
적합하게 인코딩된 모든 데이터를 집어넣을 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-14: 문자열에 다양한 언어로 인사말
저장하기</span></p>
<p>위의 모두가 유효한 <code>String</code> 값입니다.</p>
<h3 id="문자열-업데이트하기"><a class="header" href="#문자열-업데이트하기">문자열 업데이트하기</a></h3>
<p><code>String</code>은 <code>Vec</code>의 내용물처럼 더 많은 데이터를 집어넣으면 크기가
커지고 내용물은 변경될 수 있습니다. 또한 <code>+</code> 연산자나 <code>format!</code> 매크로를
사용하여 편리하게 <code>String</code> 값들을 이어붙일 수 있습니다.</p>
<h4 id="push_str과-push를-이용하여-문자열-추가하기"><a class="header" href="#push_str과-push를-이용하여-문자열-추가하기"><code>push_str</code>과 <code>push</code>를 이용하여 문자열 추가하기</a></h4>
<p>예제 8-15처럼 <code>push_str</code> 메서드를 사용하여 문자열 슬라이스를 추가하는
것으로 <code>String</code>을 키울 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-15: <code>push_str</code> 메서드를 사용하여 <code>String</code>에
문자열 슬라이스 추가하기</span></p>
<p>위의 두 줄이 실행된 후 <code>s</code>에는 <code>foobar</code>가 들어있을 것입니다. <code>push_str</code> 메서드는
문자열 슬라이스를 매개변수로 갖는데 이는 매개변수의 소유권을 가져올 필요가
없기 때문입니다. 예를 들어, 예제 8-16의 코드에서는 <code>s2</code>의 내용물을
<code>s1</code>에 추가한 후 <code>s2</code>를 쓰려고 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-16: 문자열 슬라이스를 <code>String</code>에 붙인 이후에
문자열 슬라이스를 사용하기</span></p>
<p>만일 <code>push_str</code> 함수가 <code>s2</code>의 소유권을 가져갔다면, 마지막 줄에서 이 값을
출력할 수 없었을 것입니다. 하지만 이 코드는 기대했던 대로 작동합니다!</p>
<p><code>push</code> 메서드는 한 개의 글자를 매개변수로 받아서 <code>String</code>에 추가합니다.
예제 8-17은 <code>push</code> 메서드를 사용하여 <code>String</code>에 ‘l’을 추가하고
있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-17: <code>push</code>를 사용하여 <code>String</code> 값에 한 글자
추가하기</span></p>
<p>위의 코드를 실행한 결과로 <code>s</code>는 <code>lol</code>을 담고 있을 것입니다.</p>
<h4 id="-연산자나-format-매크로를-이용한-접합"><a class="header" href="#-연산자나-format-매크로를-이용한-접합"><code>+</code> 연산자나 <code>format!</code> 매크로를 이용한 접합</a></h4>
<p>가지고 있는 두 개의 문자열을 조합하고 싶은 경우도 종종 있습니다. 예제 8-18에
표시된 것처럼 <code>+</code> 연산자를 사용하는 것이 한 가지 방법입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // s1은 여기로 이동되어 더 이상 사용할 수 없음을 주의하세요
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 8-18: <code>+</code> 연산자를 사용하여 두 <code>String</code> 값을
하나의 새로운 <code>String</code> 값으로 조합하기</span></p>
<p>문자열 <code>s3</code>는 <code>Hello, world!</code>를 담게 될 것입니다. <code>s1</code>이 더하기 연산
이후에 더 이상 유효하지 않은 이유와 <code>s2</code>의 참조자가 사용되는 이유는
<code>+</code> 연산자를 사용했을 때 호출되는 함수의 시그니처와 맞춰야 하기 때문입니다.
<code>+</code> 연산자는 <code>add</code> 메서드를 사용하는데, 이 메서드의 시그니처는 아래처럼
생겼습니다:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>표준 라이브러리에는 <code>add</code>가 제네릭과 연관 타입을 사용하여 정의되어
있습니다. 여기서는 제네릭에 구체 타입 (concrete type) 을 대입하였고,
이는 <code>String</code> 값으로 이 메서드를 호출했을 때 발생합니다. 제네릭에 대한
내용은 10장에서 다룰 것입니다. 이 시그니처는 <code>+</code> 연산자의 까다로운 부분을
이해하는 데 필요한 단서를 줍니다.</p>
<p>먼저 <code>s2</code>에는 <code>&amp;</code>가 있는데, 즉 첫 번째 문자열에 두 번째 문자열의
<em>참조자</em>를 더하고 있음을 뜻합니다. 이는 <code>add</code> 함수의 <code>s</code> 매개변수 때문입니다:
<code>String</code>에는 <code>&amp;str</code>만 더할 수 있고, 두 <code>String</code>끼리는 더하지 못합니다.
아니, 잠깐만요. <code>&amp;s2</code>의 타입은 <code>&amp;String</code>이지, <code>add</code>의 두 번째 매개변수에
지정된 <code>&amp;str</code>은 아니죠. 어째서 예제 8-18가 컴파일되는 걸까요?</p>
<p><code>&amp;s2</code>를 <code>add</code> 호출에 사용할 수 있는 이유는 <code>&amp;String</code> 인수가 <code>&amp;str</code>로 <em>강제</em>될
수 있기 때문입니다. <code>add</code> 함수가 호출되면, 러스트는 <em>역참조 강제 변환 (deref coercion)</em>
을 사용하는데, 이것이 <code>add</code> 함수 내에서 사용되는 <code>&amp;s2</code>를
<code>&amp;s2[..]</code>로 바꿉니다. 역참조 강제 변환은 15장에서 더 자세히
다루겠습니다. <code>add</code>가 매개변수의 소유권을 가져가지는 않으므로, <code>s2</code>는
이 연산 이후에도 계속 유효한 <code>String</code>일 것입니다.</p>
<p>두 번째로, 시그니처에서 <code>add</code>가 <code>self</code>의 소유권을 가져가는 것을 볼 수 있는데,
이는 <code>self</code>가 <code>&amp;</code>를 <em>안 가지고</em> 있기 때문입니다. 즉 예제 8-18에서
<code>s1</code>이 <code>add</code> 호출로 이동되어 이후에는 더 이상 유효하지 않을 것이라는 의미입니다.
따라서 <code>let s3 = s1 + &amp;s2;</code>가 마치 두 문자열을 복사하여 새로운 문자열을 만들
것처럼 보일지라도, 실제로 이 구문은 <code>s1</code>의 소유권을 가져다가 <code>s2</code>의 내용물의
복사본을 추가한 다음, 결과물의 소유권을 반환합니다. 바꿔 말하면, 이 구문은
여러 복사본을 만드는 것처럼 보여도 그렇지 않습니다: 이러한 구현은 복사보다
더 효율적입니다.</p>
<p>만일 여러 문자열을 접하고자 한다면, <code>+</code>의 동작은 다루기 불편해
집니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>이 시점에서 <code>s</code>는 <code>tic-tac-toe</code>가 될 것입니다. <code>+</code>와 <code>"</code> 문자가 많으면
어떤 결과가 나올지 확인이 어렵습니다. 더 복잡한 문자열 조합에는 대신
<code>format!</code> 매크로를 사용할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>이 코드 또한 <code>s</code>에 <code>tic-tac-toe</code>를 설정합니다. <code>format!</code> 매크로는
<code>println!</code>처럼 작동하지만, 화면에 결과를 출력하는 대신 결과가 담긴
<code>String</code>을 반환해 줍니다. <code>format!</code>을 이용한 버전이 훨씬 읽기 쉽고,
<code>format!</code> 매크로로 만들어진 코드는 참조자를 이용하므로 이 호출은
아무 매개변수의 소유권도 가져가지 않습니다.</p>
<h3 id="문자열-내부의-인덱싱"><a class="header" href="#문자열-내부의-인덱싱">문자열 내부의 인덱싱</a></h3>
<p>다른 많은 프로그래밍 언어에서, 인덱스를 이용한 참조를 통해 문자열 내부의
개별 문자에 접근하는 것은 유효하고 범용적인 연산에 속합니다. 그러나 러스트에서
인덱싱 문법을 이용하여 <code>String</code>의 부분에 접근하고자 하면 에러를 얻게 됩니다.
아래 예제 8-19와 같은 코드를 생각해 봅시다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let h = s1[0];
<span class="boring">}</span></code></pre>
<p><span class="caption">예제 8-19: 문자열에 인덱싱 문법을 사용하는
시도</span></p>
<p>이 코드는 아래와 같은 에러를 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`
  = help: the following other types implement trait `Index&lt;Idx&gt;`:
            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeFull&gt;&gt;
            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>에러와 노트 부분이 이야기해 줍니다: 러스트 문자열은 인덱싱을 지원하지 않는다고
하는군요. 그런데 왜 안 되는 걸까요? 이 질문에 답하기 위해서는 러스트가 문자열을
메모리에 저장하는 방법에 대해 설명해야 합니다.</p>
<h4 id="내부적-표현"><a class="header" href="#내부적-표현">내부적 표현</a></h4>
<p><code>String</code>은 <code>Vec&lt;u8&gt;</code>을 감싼 것입니다. 예제 8-14에서 보았던 적합하게
인코딩된 UTF-8 예제 문자을 몇 가지를 살펴봅시다. 첫 번째로, 이것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שָׁלוֹם");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>이 경우 <code>len</code>은 4가 되는데, 이는 문자열 ‘Hola’를 저장하고 있는 <code>Vec</code>이
4바이트 길이라는 뜻입니다. UTF-8으로 인코딩되면 각각의 글자들이 1바이트씩
차지한다는 것이죠. 그러나 다음 줄은 아마도 여러분을 놀라게 할 수도 있습니다.
(맨 앞의 문자는 아라비아 숫자 3이 아닌, 키릴 문자 Ze입니다.)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שָׁלוֹם");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>이 문자열의 길이가 얼마인지 묻는다면, 여러분은 12라고 답할지도 모릅니다. 실제 러스트의
대답은 24입니다. 이는 "Здравствуйте"를 UTF-8으로 인코딩된 바이트들의 크기인데, 각각의
유니코드 스칼라 값이 저장소의 2바이트를 차지하기 때문입니다. 따라서, 문자열의 바이트 안의
인덱스는 유효한 유니코드 스칼라 값과 항상 대응되지는 않을 것입니다. 이를 설명하기 위해
다음과 같은 유효하지 않은 러스트 코드를 고려해 보겠습니다:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>여러분은 이미 <code>answer</code>가 첫 번째 글자인 <code>З</code>이 아닐 것이란 점을 알고 있습니다.
UTF-8으로 인코딩될 때, <code>З</code>의 첫 번째 바이트는 <code>208</code>이고, 두 번째는 <code>151</code>이므로,
<code>answer</code>는 사실 <code>208</code>이 되어야 하지만, <code>208</code>은 그 자체로는 유효한 문자가
아닙니다. <code>208</code>을 반환하는 것은 이 문자열의 첫 번째 글자를 요청했을 때
예상한 것이 아닙니다. 하지만 그게 러스트가 인덱스 0에 가지고 있는
유일한 데이터죠. 라틴 글자들만 있는 경우일지라도, 일반적으로 바이트 값의
반환이 사용자들이 원하는 것은 아닐 겁니다. : <code>&amp;"hello"[0]</code>는 <code>h</code>가
아니라 <code>104</code>를 반환합니다.</p>
<p>따라서 예상치 못한 값을 반환하고 즉시 발견되지 않을 수 있는 버그를 방지하기
위해서, 러스트는 이러한 코드를 전혀 컴파일하지 않고 이러한 오해들을
개발 과정 내에서 일찌감치 방지한다는 것이 정답입니다.</p>
<h4 id="바이트와-스칼라-값과-문자소-클러스터-이런"><a class="header" href="#바이트와-스칼라-값과-문자소-클러스터-이런">바이트와 스칼라 값과 문자소 클러스터! 이런!</a></h4>
<p>UTF-8에 대한 또 다른 요점은, 실제로는 러스트의 관점에서 문자열을 보는
세 가지 관련 방식이 있다는 것입니다: 바이트, 스칼라 값, 그리고 문자소
클러스터 (grapheme cluster, 우리가 <em>글자</em>라고 부르는 것과 가장 근접한 것) 입니다.</p>
<p>데바나가리 (Devanagari) 글자로 쓰인 힌디어 ‘नमस्ते’를 보면, 이것은 궁극적으로 아래와
같은 <code>u8</code> 값들의 <code>Vec</code>으로 저장됩니다:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>이건 18바이트이고 컴퓨터가 이 데이터를 궁극적으로 저장하는 방법입니다.
만일 이를 유니코드 스칼라 값, 즉 러스트의 <code>char</code> 타입인 형태로
본다면, 아래와 같이 보이게 됩니다:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>여섯 개의 <code>char</code> 값이 있지만, 네 번째와 여섯 번째는 글자가 아닙니다: 그
자체로는 이해할 수 없는 발음 구별 부호입니다. 마지막으로, 이 문자열을
문자소 클러스터로 본다면, 이 힌디 단어를 구성하는 네 글자를 알아낼 수
있습니다:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>러스트는 컴퓨터가 저장하는 원시 문자열 (raw string) 을 번역하는 다양한
방법을 제공하여, 데이터가 담고 있는 것이 무슨 언어든 상관없이 각 프로그램이
필요로 하는 통역방식을 선택할 수 있도록 합니다.</p>
<p>러스트가 <code>String</code>을 인덱스로 접근하여 문자를 얻지 못하도록 하는 마지막 이유는
인덱스 연산이 언제나 상수 시간(O(1))에 실행될 것으로 기대받기 때문입니다.
그러나 <code>String</code>을 가지고 그러한 성능을 보장하는 것은 불가능한데, 그 이유는
러스트가 문자열 내에 유효한 문자가 몇 개 있는지 알아내기 위해 내용물을
시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문입니다.</p>
<h3 id="문자열-슬라이싱하기"><a class="header" href="#문자열-슬라이싱하기">문자열 슬라이싱하기</a></h3>
<p>문자열 인덱싱의 반환 타입이 어떤 것이 (바이트 값인지, 캐릭터인지, 문자소
클러스터인지, 혹은 문자열 슬라이스인지) 되어야 하는지 명확하지 않기 때문에
문자열의 인덱싱은 종종 좋지 않은 생각이 됩니다. 따라서 문자열 슬라이스를 만들기
위해 정말로 인덱스를 사용하고자 한다면 러스트는 좀 더 구체적인 지정을 요청합니다.</p>
<p><code>[]</code>에 숫자 하나를 사용하는 인덱싱이 아니라 <code>[]</code>와 범위를 사용하여
특정 바이트들이 담고 있는 문자열 슬라이스를 만들 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>s</code>는 문자열의 첫 4바이트를 담고 있는 <code>&amp;str</code>가 됩니다. 앞서 우리는
이 글자들이 각각 2바이트를 차지한다고 언급했으므로, 이는 <code>s</code>가 ‘Зд’이 될 것이란
뜻입니다.</p>
<p>만약에 <code>&amp;hello[0..1]</code>처럼 문자 바이트의 일부를 슬라이스를 얻으려고 한다면,
러스트는 벡터 내에 유효하지 않은 인덱스에 접근했을 때와 동일한 방식으로
런타임에 패닉을 발생시킬 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>범위를 지정하여 문자열 슬라이스를 생성하는 것은 프로그램을 죽게 만들 수도
있기 때문에 주의깊게 사용되어야 합니다.</p>
<h3 id="문자열에-대한-반복을-위한-메서드"><a class="header" href="#문자열에-대한-반복을-위한-메서드">문자열에 대한 반복을 위한 메서드</a></h3>
<p>문자열 조각에 대한 연산을 하는 가장 좋은 방법은 명시적으로 문자를 원하는 것인지
아니면 바이트를 원하는 것인지 지정하는 것입니다. 개별적인 유니코드 스칼라 값에 대해서는
<code>chars</code> 메서드를 사용하세요. ‘Зд’에 대해 <code>chars</code> 함수를 호출하면 각각을 분리하여 <code>char</code>
타입의 두 개의 값을 반환하고, 이 결과에 대한 반복을 통하여 각 요소에 접근할 수
있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 다음을 출력할 것입니다:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>다른 방법으로 <code>bytes</code> 메서드는 각 원시 바이트를 반환하는데, 문제의
도메인이 무엇인가에 따라 적절할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>위의 코드는 이 문자열을 구성하는 네 개의 바이트를 출력합니다:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>하지만 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는
것을 확실히 기억해 주세요.</p>
<p>데바나가리 문서와 같은 문자열로부터 문자소 클러스터를 얻는
방법은 복잡해서, 이 기능은 표준 라이브러리를 통해 제공되지 않습니다.
여러분이 원하는 기능이 이것이라면 <a href="https://crates.io/">crates.io</a><!-- ignore -->에
사용 가능한 크레이트가 있습니다.</p>
<h3 id="문자열은-그렇게-단순하지-않습니다"><a class="header" href="#문자열은-그렇게-단순하지-않습니다">문자열은 그렇게 단순하지 않습니다</a></h3>
<p>요약하자면, 문자열은 복잡합니다. 프로그래밍 언어마다 이러한 복잡성을
프로그래머에게 표현하는 방법에 대해 다른 선택을 합니다. 러스트는
<code>String</code> 데이터의 올바른 처리가 모든 러스트 프로그램의 기본 동작으로
선택했는데, 이는 프로그래머가 UTF-8 데이터를 처리할 때 미리 더 많은
생각을 해야 함을 의미합니다. 이러한 절충안은 다른 프로그래밍 언어보다
문자열의 복잡성을 더 많이 노출시키지만, 한편으로는 여러분의 개발 수명
주기 후반에 ASCII 아닌 문자와 관련된 에러를 처리해야 할 필요가 없도록
해줍니다.</p>
<p>좋은 소식은 표준 라이브러리에 이런 복잡한 상황을 올바르게 처리하는 데
도움이 될 <code>String</code> 및 <code>&amp;str</code> 타입 기반의 기능을 다양하게 제공한다는
점입니다. 문자열 검색을 위한 <code>contains</code>와 문자열 일부를 다른 문자열로
바꾸는 <code>replace</code> 같은 유용한 메서드들에 대해 알아보려면 꼭 문서를
확인해 보세요.</p>
<p>이것보다 살짝 덜 복잡한 것으로 옮겨 갑시다: 해시맵이요!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
