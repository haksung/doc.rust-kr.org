<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>고급 타입 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="고급-타입"><a class="header" href="#고급-타입">고급 타입</a></h2>
<p>러스트의 타입 시스템에는 지금까지 언급은 했지만 아직 논의하지는 않은
몇 가지 기능이 있습니다. 먼저 뉴타입이 타입으로써 유용한 이유를 살펴보면서
뉴타입에 대해 전반적으로 논의하겠습니다. 그런 다음 뉴타입과 비슷하지만 의미는
약간 다른 기능인 타입 별칭 (type alias) 에 대해 살펴보겠습니다. 또한 <code>!</code>
타입과 동적 크기 타입 (dynamically sized type) 에 대해서도 설명합니다.</p>
<h3 id="타입-안전성과-추상화를-위한-뉴타입-패턴-사용하기"><a class="header" href="#타입-안전성과-추상화를-위한-뉴타입-패턴-사용하기">타입 안전성과 추상화를 위한 뉴타입 패턴 사용하기</a></h3>
<blockquote>
<p>Note: 이 절은 여러분이 이전에 나온
<a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">‘뉴타입 패턴을 사용하여 외부 타입에 외부 트레이트 구현하기’</a><!-- ignore -->절을
읽었다고 가정합니다.</p>
</blockquote>
<p>뉴타입 패턴은 지금까지 설명한 것 이외의 작업에도 유용한데, 여기에는
값이 혼동되지 않도록 정적으로 강제하는 것과 값의 단위를 표시하는
것들이 포함됩니다. 예제 19-15에서 뉴타입을 사용하여 단위를 표시하는
예제를 보았습니다: <code>Millimeters</code> 및 <code>Meters</code> 구조체가 <code>u32</code> 값을
뉴타입으로 감싸고 있었음을 상기하세요. <code>Millimeters</code> 타입의
매개변수가 있는 함수를 작성했다면, 실수로 <code>Meters</code> 또는 보통의
<code>u32</code> 타입의 값으로 해당 함수를 호출 시도하는 프로그램은 컴파일될
수 없습니다.</p>
<p>뉴타입 패턴은 어떤 타입의 구현 세부 사항을 추상화하는데도
사용 가능합니다: 뉴타입은 비공개 내부 타입의 API와는 다른 공개
API를 노출할 수 있습니다.</p>
<p>뉴타입은 내부 구현을 숨길 수도 있습니다. 예를 들면, 어떤 사람의 ID와
이에 연관된 그 사람의 이름을 저장하는 <code>HashMap&lt;i32, String&gt;</code>을
감싼 <code>People</code> 타입을 만들 수 있습니다. <code>People</code>을 사용하는
코드는 <code>People</code> 컬렉션에 이름 문자열을 추가하는 메서드처럼
우리가 제공하는 공개 API와만 상호작용할 수 있습니다; 해당
코드는 내부적으로 이름에 <code>i32</code> ID를 할당한다는 사실을 알 필요가
없습니다. 뉴타입 패턴은 구현 세부 사항을 숨기는 캡슐화를 달성하는
가벼운 방법으로, 17장의
<a href="ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">‘상세 구현을 은닉하는 캡슐화’</a><!-- ignore -->절에서
설명한 바 있습니다.</p>
<h3 id="타입-별칭으로-타입의-동의어-만들기"><a class="header" href="#타입-별칭으로-타입의-동의어-만들기">타입 별칭으로 타입의 동의어 만들기</a></h3>
<p>러스트는 <em>타입 별칭 (type alias)</em> 을 선언하여 기존 타입에 다른 이름을 부여하는
기능을 제공합니다. 이를 위해서는 <code>type</code> 키워드를 사용합니다. 예를 들어, 다음과
같이 <code>i32</code>에 대한 <code>Kilometers</code>라는 별칭을 만들 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>이제 별칭 <code>Kilometers</code>는 <code>i32</code>의 <em>동의어</em>입니다; 예제 19-15에서
만든 <code>Millimeters</code> 및 <code>Meters</code> 타입과는 달리, <code>Kilometers</code>는 별도의
새로운 타입은 아닙니다. <code>Kilometers</code> 타입을 가진 값은 <code>i32</code> 타입의 값과
동일하게 처리됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p><code>Kilometers</code>와 <code>i32</code>는 동일한 타입이므로 두 타입의 값을 모두 더할
수 있고 <code>Kilometers</code> 값을 <code>i32</code> 매개변수를 받는 함수에 전달할 수
있습니다. 그러나, 이 방법을 사용하면 이전에 설명한 뉴타입 패턴에서
얻을 수 있는 타입 검사 이점을 얻을 수 없습니다. 다시 말해, 어딘가에서
<code>Kilometers</code>와 <code>i32</code> 값을 혼용하면 컴파일러는 에러를 표시하지
않습니다.</p>
<p>타입 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어,
다음과 같은 긴 타입이 있을 수 있습니다:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>이 긴 타입을 함수 시그니처 및 코드의 모든 곳에 타입 명시로 작성하는
것은 지루하고 에러가 발생하기 쉽습니다. 예제 19-24와 같은 코드로
가득 찬 프로젝트가 있다고 상상해 보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --생략--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-24: 수많은 곳에 긴 타입 사용하기</span></p>
<p>타입 별칭은 반복을 줄여 이 코드를 관리하기 쉽게 만듭니다. 예제 19-25에서는
이 장황한 타입에 대해 <code>Thunk</code>라는 별칭을 만들고 이 타입이
사용된 모든 곳을 짧은 별칭 <code>Thunk</code>로 대체했습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --생략--
    }

    fn returns_long_type() -&gt; Thunk {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">예제 19-25: 타입 별칭 <code>Thunk</code>을 도입하여
반복 줄이기</span></p>
<p>이 코드는 읽고 작성하기 훨씬 쉽습니다! 또한 타입 별칭에 의미 있는
이름을 선택하면 의도를 전달하는 데 도움이 됩니다. (<em>thunk</em>는
나중에 평가될 코드를 나타내는 단어이므로, 저장되는 클로저에 적합한
이름입니다.)</p>
<p>타입 별칭은 또한 <code>Result&lt;T, E&gt;</code> 타입의 반복을 줄이기 위해 사용되기도
합니다. 표준 라이브러리의 <code>std::io</code> 모듈을 생각해 보세요. I/O 연산은
종종 연산이 작동하지 않을 때의 상황을 처리하기 위해 <code>Result&lt;T, E&gt;</code>를
반환합니다. 이 라이브러리에는 가능한 모든 I/O 에러를 나타내는
<code>std::io::Error</code> 구조체가 있습니다. <code>std::io</code>의 많은 함수는 <code>Write</code>
트레이트의 함수와 같이 <code>E</code>가 <code>std::io::Error</code>인 <code>Result&lt;T, E&gt;</code>를
반환합니다:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code>가 많이 반복됩니다. 이러한 이유로 <code>std::io</code>에는
이러한 타입 별칭 선언이 있습니다:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>이 선언이 <code>std::io</code> 모듈에 있으므로, 완전 정규화된 별칭
<code>std::io::Result&lt;T&gt;</code>를 사용할 수 있습니다; 즉, <code>E</code>가
<code>std::io::Error</code>로 채워진 <code>Result&lt;T, E&gt;</code>입니다. <code>Write</code> 트레이트
함수 시그니처는 결국 다음과 같이 생기게 됩니다:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>타입 별칭은 두 가지 방법으로 도움을 줍니다: 코드를 쉽게 작성할 수 있게 해 주고,
<em>그러면서도</em> <code>std::io</code> 전체에 일관된 인터페이스를 제공합니다. 이것은 별칭이기
때문에 그저 또 다른 <code>Result&lt;T, E&gt;</code>일 뿐이고, 이는 <code>Result&lt;T, E&gt;</code>에서 작동하는
모든 메서드는 물론, <code>?</code> 연산자와 같은 특별 문법도 사용할 수 있음을 뜻합니다.</p>
<h3 id="절대-반환하지-않는-부정-타입"><a class="header" href="#절대-반환하지-않는-부정-타입">절대 반환하지 않는 부정 타입</a></h3>
<p>러스트에는 <code>!</code>라는 특수한 타입이 있는데, 이 타입은 값이 없기 때문에 타입
이론 용어로는 <em>빈 타입 (empty type)</em> 이라고 알려져 있습니다. 함수가 절대
반환하지 않을 때 반환 타입을 대신하기 때문에 <em>부정 타입 (never type)</em> 이라고
부르는 쪽이 선호됩니다. 다음은 예시입니다:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --생략--
<span class="boring">    panic!();
</span>}</code></pre>
<p>이 코드는 ‘함수 <code>bar</code>는 절대로 반환하지 않습니다’라고 읽습니다. 절대로 반환하지
않는 함수는 <em>발산 함수 (diverging functions)</em> 라고 합니다. <code>!</code> 타입의 값은
만들 수 없으므로, <code>bar</code>는 절대 반환할 수 없습니다.</p>
<p>그런데 값을 절대로 만들 수 없는 타입은 어디에 쓰는 거죠? 숫자 추리 게임의
부분인 예제 2-5의 코드를 기억해 보세요; 여기에 예제 19-26에서
다시 일부를 재현해 두었습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">예제 19-26: <code>continue</code>로 끝나는 갈래가
있는 <code>match</code></span></p>
<p>이 시점에서는 이 코드에서 몇 가지 세부 사항을 건너뛰었습니다. 6장의
<a href="ch06-02-match.html#the-match-control-flow-operator">‘<code>match</code> 제어 흐름 연산자’</a><!-- ignore -->절에서
<code>match</code> 갈래가 모두 같은 타입을 반환해야 한다는 것을 논의했습니다. 예를 들어,
다음 코드는 작동하지 않습니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p><code>guess</code>의 타입은 정수 <em>그리고</em> 문자열이어야 하며, 러스트는
<code>guess</code>가 하나의 타입만 가져야 한다고 요구합니다. 그럼 <code>continue</code>가
무엇을 반환할까요? 어떻게 예제 19-26에서 한쪽 갈래는 <code>u32</code>를
반환하면서 다른 갈래는 <code>continue</code>로 끝나는 것이 허용되었을까요?</p>
<p>짐작하셨겠지만, <code>continue</code>는 <code>!</code> 값을 가집니다. 즉, 러스트가 <code>guess</code>의
타입을 계산할 때, 두 개의 매치 갈래를 모두 살펴보게 되는데, 전자는 <code>u32</code> 값을
가지고 후자는 <code>!</code> 값을 가집니다. <code>!</code>는 절대로 값을 가질 수 없으므로, 러스트는
<code>guess</code>의 타입이 <code>u32</code>라고 결정합니다.</p>
<p>이 동작을 설명하는 공식적인 방법은 <code>!</code> 타입의 표현식이 다른 모든 타입으로
강제 변환될 수 있다는 것입니다. <code>continue</code>가 값을 반환하지 않기 때문에,
이 <code>match</code> 갈래가 <code>continue</code>로 끝나도 괜찮습니다; <code>continue</code>는 제어를
반복문의 맨 위로 이동시키기 때문에, <code>Err</code> 케이스에서는 <code>guess</code>에 값을
할당하지 않습니다.</p>
<p>부정 타입은 <code>panic!</code> 매크로와 함께 유용하게 쓰입니다. 값을 생성하거나
패닉을 일으키기 위해 <code>Option&lt;T&gt;</code> 값에서 호출한 <code>unwrap</code> 함수를 기억해
보시면, 여기 그 정의가 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>이 코드에서도 예제 19-26의 <code>match</code>에서와 같은 일이 발생합니다: <code>val</code>이
<code>T</code> 타입을 가지고 있고 <code>panic!</code>이 <code>!</code> 타입을 가지고 있으므로, 러스트는 전체
<code>match</code> 표현식의 결과가 <code>T</code>라는 것을 알 수 있습니다. 이 코드는 <code>panic!</code>이
값을 생성하지 않기 때문에 작동합니다; 패닉은 프로그램을 종료하니까요. <code>None</code>의
경우 <code>unwrap</code>에서 값을 반환하지 않으므로, 이 코드는 유효합니다.</p>
<p><code>!</code> 타입을 가지는 마지막 표현식은 <code>loop</code>입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>여기서 루프는 절대 끝나지 않으므로, <code>!</code>가 이 표현식의 값이 됩니다. 하지만
<code>break</code>를 포함시키면, 루프는 <code>break</code>에 도달했을 때 종료되므로, 이는
참이 아니게 될 것입니다.</p>
<h3 id="동적-크기-타입과-sized-트레이트"><a class="header" href="#동적-크기-타입과-sized-트레이트">동적 크기 타입과 <code>Sized</code> 트레이트</a></h3>
<p>러스트는 특정 타입의 값에 할당할 공간의 크기 등 타입에 대한 특정 세부
사항을 알아야 합니다. 이로 인해 처음에는 타입 시스템의 한구석이 약간
혼란스럽습니다: 바로 <em>동적 크기 타입 (dynamically sized type)</em> 의 개념이 그렇습니다.
<em>DST</em> 또는 <em>크기가 지정되지 않은 타입 (unsized type)</em> 이라고도 하는 이러한 타입을
사용하면 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있습니다.</p>
<p>이 책 전체에 걸쳐 사용했던 <code>str</code>이라는 동적 크기 타입에 대해 자세히
알아보겠습니다. 그렇습니다. <code>&amp;str</code>이 아니라 <code>str</code> 자체는 DST입니다.
런타임이 될 때까지 문자열의 길이를 알 수 없으므로 <code>str</code> 타입의 변수를
만들 수도 없고, <code>str</code> 타입의 인수를 받을 수도 없습니다. 아래의
작동하지 않는 코드를 고려해 보세요:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>러스트는 특정 타입의 값에 할당할 메모리의 크기를 알아야 하며,
타입의 모든 값은 동일한 크기의 메모리를 사용해야 합니다. 러스트에서
이 코드를 작성할 수 있다면 이 두 <code>str</code> 값은 같은 양의 공간을 차지해야
합니다. 그러나 이들은 길이가 다릅니다: <code>s1</code>은 12바이트의 저장 공간이
필요하고 <code>s2</code>는 15바이트가 필요하기 때문입니다. 이것이 바로 동적 크기를
갖는 변수를 생성할 수 없는 이유입니다.</p>
<p>그럼 어떻게 해야 할까요? 이 경우에는 이미 답을 알고 있습니다: <code>s1</code>과
<code>s2</code>의 타입을 <code>str</code>이 아닌 <code>&amp;str</code>로 만듭니다. 4장의
<a href="ch04-03-slices.html#string-slices">‘문자열 슬라이스’</a><!-- ignore -->절에서 슬라이스
데이터 구조는 슬라이스의 시작 위치와 길이만 저장한다는 것을 기억하세요.
따라서 <code>&amp;T</code>는 <code>T</code>가 위치한 메모리 주소를 저장하는 단일 값이지만,
<code>&amp;str</code>은 <em>두 개의</em> 값입니다: <code>str</code>의 주소와 길이 말이지요. 따라서
컴파일 타임에 <code>&amp;str</code> 값의 크기를 알 수 있습니다: <code>usize</code> 길이의
두 배입니다. 즉, <code>&amp;str</code>이 참조하는 문자열의 길이가 아무리 길어도
항상 <code>&amp;str</code>의 크기를 알 수 있습니다. 일반적으로 이것이 러스트에서
동적 크기 타입이 사용되는 방식입니다: 이들은 동적 정보의 크기를
저장하는 추가 메타데이터를 가지고 있습니다. 동적 크기 타입의
황금률은 동적 크기 타입의 값을 항상 어떤 종류의 포인터 뒤에 넣어야
한다는 것입니다.</p>
<p><code>str</code>은 모든 종류의 포인터와 결합할 수 있습니다: 예를 들면, <code>Box&lt;str&gt;</code>나 <code>Rc&lt;str&gt;</code>
같은 것들이지요. 사실, 여러분은 이전에도 다른 종류의 동적 크기 타입이지만
이런 것을 본 적이 있습니다: 바로 트레이트입니다. 모든 트레이트는 그 트레이트의 이름을
사용하여 참조할 수 있는 동적 크기 타입입니다. 17장의
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‘트레이트 객체를 사용하여 다른 타입의 값 허용하기’</a><!-- ignore -->절에서,
트레이트를 트레이트 객체로 사용하려면
<code>&amp;dyn Trait</code> 또는 <code>Box&lt;dyn Trait&gt;</code>와
같은 포인터 뒤에 넣어야 한다고 언급했습니다. (<code>Rc&lt;dyn Trait&gt;</code>도
가능합니다.)</p>
<p>DST로 작업하기 위해 러스트에서는 컴파일 시점에 타입의 크기를 알 수
있는지 여부를 결정하는 <code>Sized</code> 트레이트를 제공합니다. 이 트레이트는
컴파일 시 크기가 알려진 모든 것에 대해 자동으로 구현됩니다. 또한
러스트는 암묵적으로 모든 제네릭 함수에 <code>Sized</code> 바운드를 추가합니다.
즉, 다음과 같은 제네릭 함수 정의는:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --생략--
}</code></pre>
<p>실제로는 아래와 같이 작성한 것처럼 취급됩니다:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --생략--
}</code></pre>
<p>기본적으로 제네릭 함수는 컴파일 시점에 크기가 알려진 타입에 대해서만
작동합니다. 그러나 다음과 같은 특별 문법을 사용하여 이 제한을 완화할
수 있습니다:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --생략--
}</code></pre>
<p><code>?Size</code> 트레이트 바운드는 ‘<code>T</code>는 <code>Sized</code>일 수도 있고 아닐 수도 있다’는 의미를
가지며 이 문법은 제네릭 타입이 컴파일 시점에 크기가 알려진 타입이어야 한다는
기본값을 덮어씁니다. 이런 의미의 <code>?Trait</code> 문법은 <code>Sized</code>에만 사용할 수 있고
다른 어떤 트레이트에도 사용할 수 없습니다.</p>
<p>또한 <code>t</code> 매개변수의 타입을 <code>T</code>에서 <code>&amp;T</code>로 바꾸었음을 주목하세요.
타입이 <code>Sized</code>가 아닐 수 있기 때문에 어떤 종류의 포인터 뒤에 놓고
사용해야 합니다. 이 경우에는 참조를 선택했습니다.</p>
<p>다음으로는 함수와 클로저에 대해 이야기해 보겠습니다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-03-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
