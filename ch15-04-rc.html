<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rc&lt;T&gt;, 참조 카운트 스마트 포인터 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="rct-참조-카운트-스마트-포인터"><a class="header" href="#rct-참조-카운트-스마트-포인터"><code>Rc&lt;T&gt;</code>, 참조 카운트 스마트 포인터</a></h2>
<p>대부분의 경우에서 소유권은 명확합니다: 즉 어떤 변수가 주어진 값을
소유하는지 정확히 압니다. 그러나 하나의 값이 여러 개의 소유자를 가질 수
있는 경우도 있습니다. 예를 들어, 그래프 데이터 구조에서 여러 에지가
동일한 노드를 가리킬 수도 있고, 그 노드는 개념적으로 해당 노드를 가리키는
모든 에지에 의해 소유됩니다. 노드는 어떠한 에지도 이를 가리키지 않아
소유자가 하나도 없는 상태가 아니라면 메모리 정리가 되어서는 안 됩니다.</p>
<p>명시적으로 복수 소유권을 가능하게 하려면 러스트의 <code>Rc&lt;T&gt;</code> 타입을 이용해야
하는데, 이는 <em>참조 카운팅 (reference counting)</em> 의 약자입니다. <code>Rc&lt;T&gt;</code>
타입은 어떤 값의 참조자 개수를 계속 추적하여 해당 값이 계속 사용 중인지를
판단합니다. 만일 어떤 값에 대한 참조자가 0개라면 이 값의 메모리 정리를
하더라도 유효하지 않은 참조자가 발생하지 않을 수 있습니다.</p>
<p><code>Rc&lt;T&gt;</code>를 거실의 TV라고 상상해 봅시다. 한 사람이 TV를 보러 들어올 때
TV를 켭니다. 다른 사람들은 거실로 들어와서 TV를 볼 수 있습니다. 마지막 사람이
거실을 나선다면, TV는 더 이상 사용되고 있지 않으므로 끕니다. 만일 누군가
계속 TV를 보고 있는 중에 어떤 이가 꺼버리면, 남아있던 TV 시청자들로부터 엄청난
소란이 있겠죠!</p>
<p><code>Rc&lt;T&gt;</code> 타입은 프로그램의 여러 부분에서 읽을 데이터를 힙에 할당하고
싶은데 컴파일 타임에는 어떤 부분이 그 데이터를 마지막에 이용하게 될지
알 수 없는 경우 사용됩니다. 만일 어떤 부분이 마지막으로 사용하는지
알았다면, 그냥 그 해당 부분을 데이터의 소유자로 만들면 되고, 보통의
소유권 규칙이 컴파일 타임에 수행되어 효력을 발생시킬 겁니다.</p>
<p><code>Rc&lt;T&gt;</code>는 오직 싱글스레드 시나리오용이라는 점을 주의하세요. 16장에서
동시성 (cuncurrency) 에 대한 논의를 할 때, 멀티스레드 프로그램에서
참조 카운팅을 하는 방법을 다루겠습니다.</p>
<h3 id="rct를-사용하여-데이터-공유하기"><a class="header" href="#rct를-사용하여-데이터-공유하기"><code>Rc&lt;T&gt;</code>를 사용하여 데이터 공유하기</a></h3>
<p>예제 15-5의 콘스 리스트 예제로 돌아가 봅시다. <code>Box&lt;T&gt;</code>를 이용해서 이를
정의했던 것을 상기합시다. 이번에는 두 개의 리스트를 만들고 이 둘이 모두 세 번째
리스트의 소유권을 공유하도록 하겠습니다. 개념적으로는 그림 15-3처럼 생겼습니다:</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">그림 15-3: 세 번째 리스트 <code>a</code>의 소유권을 공유하는
두 리스트 <code>b</code>와 <code>c</code></span></p>
<p>먼저 5와 10을 담은 리스트 <code>a</code>를 만들겠습니다. 그런 다음 두 개의 리스트를 더
만들 것입니다: 3으로 시작하는 <code>b</code>와 4로 시작하는 <code>c</code>를 말이죠. 그리고서 <code>b</code>와
<code>c</code> 리스트 둘 모두 5와 10을 가지고 있는 첫 번째 <code>a</code> 리스트로 계속되도록 하겠습니다.
바꿔 말하면, 두 리스트 모두 5와 10을 담고 있는 첫 리스트를 공유하게 될 것입니다.</p>
<p>예제 15-17과 같이 <code>Box&lt;T&gt;</code>를 가지고 정의한 <code>List</code>를 이용하여 이
시나리오의 구현을 시도하면 작동하지 않을 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
<p><span class="caption">예제 15-17: <code>Box&lt;T&gt;</code>를 이용한 두 리스트가 세 번째
리스트에 대한 소유권을 공유하는 시도는 허용되지 않음을 보이는 예</span></p>
<p>이 코드를 컴파일하면 다음과 같은 에러를 얻습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p><code>Cons</code> 배리언트는 자신이 들고 있는 데이터를 소유하므로, <code>b</code> 리스트를 만들 때
<code>a</code>는 <code>b</code> 안으로 이동되어 <code>b</code>의 소유가 됩니다. 그다음 <code>c</code>를 생성할 때 <code>a</code>를
다시 사용하려 할 경우는 허용되지 않는데, 이미 <code>a</code>가 이동되었기 때문입니다.</p>
<p><code>Cons</code>의 정의를 변경하여 참조자를 대신 들고 있도록 할 수도 있지만, 그러면
라이프타임 매개변수를 명시해야 할 것입니다. 라이프타임 매개변수를 명시함으로써,
리스트 내의 모든 요소가 최소한 전체 리스트만큼 오래 살아있도록 지정할
것입니다. 이는 예제 15-17의 요소와 리스트에 대한 경우지, 모든 시나리오에
맞는 것은 아닙니다.</p>
<p>그 대신 예제 15-18과 같이 <code>Box&lt;T&gt;</code>의 자리에 <code>Rc&lt;T&gt;</code>를 이용하는
형태로 <code>List</code>의 정의를 바꾸겠습니다. 각각의 <code>Cons</code> 배리언트는 이제 어떤
값과 <code>List</code>를 가리키는 <code>Rc&lt;T&gt;</code>를 갖게 될 것입니다. <code>b</code>를 만들 때는 <code>a</code>의
소유권을 얻는 대신, <code>a</code>를 가지고 있는 <code>Rc&lt;List&gt;</code>를 클론할 것인데, 이는
참조자의 개수를 하나에서 둘로 증가시키고 <code>a</code>와 <code>b</code>가 <code>Rc&lt;List&gt;</code> 안에
있는 데이터의 소유권을 공유하도록 해줍니다. 또한 <code>c</code>를 만들 때도 <code>a</code>를
클론할 것인데, 이로써 참조자의 개수가 둘에서 셋으로 늘어납니다. <code>Rc::clone</code>가
호출될 때마다 그 <code>Rc&lt;List&gt;</code>가 가지고 있는 데이터에 대한 참조 카운트는
증가할 것이고, 그 데이터는 참조자가 0개가 되지 않으면 메모리가 정리되지
않을 것입니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<p><span class="caption">예제 15-18: <code>Rc&lt;T&gt;</code>를 이용하는 <code>List</code>
정의</span></p>
<p><code>Rc&lt;T&gt;</code>는 프렐루드에 포함되어 있지 않으므로 이를 스코프로 가져오려면 <code>use</code>
구문을 추가해야 합니다. <code>main</code> 안에서 5와 10을 가지고 있는 리스트가 만들어지고
이것이 <code>a</code>의 새로운 <code>Rc&lt;List&gt;</code>에 저장됩니다. 그다음 <code>b</code>와 <code>c</code>를 만들 때는
<code>Rc::clone</code> 함수를 호출하고 <code>a</code>의 <code>Rc&lt;List&gt;</code>에 대한 참조자를 인수로서
넘깁니다.</p>
<p><code>Rc::clone(&amp;a)</code> 대신 <code>a.clone()</code>을 호출할 수도 있지만, 위의 경우
러스트의 관례는 <code>Rc::clone</code>를 이용하는 것입니다. <code>Rc::clone</code>의 구현체는
대부분의 타입들에 대한 <code>clone</code> 구현체들이 그러하듯 모든 데이터에 대한 깊은
복사 (deep copy) 를 하지 않습니다. <code>Rc::clone</code>의 호출은 오직 참조 카운트만
증가시키는데, 이는 시간이 얼마 걸리지 않습니다. 데이터의 깊은 복사는 많은
시간이 걸릴 수 있습니다. 참조 카운팅을 위해 <code>Rc::clone</code>을 사용함으로써
깊은 복사 종류의 클론과 참조 카운트를 증가시키는 종류의 클론을 시각적으로
구별할 수 있습니다. 코드에서 성능 문제를 찾는 중이라면 깊은 복사 클론만
고려할 필요가 있고 <code>Rc::clone</code> 호출은 무시할 수
있습니다.</p>
<h3 id="rct를-클론하는-것은-참조-카운트를-증가시킵니다"><a class="header" href="#rct를-클론하는-것은-참조-카운트를-증가시킵니다"><code>Rc&lt;T&gt;</code>를 클론하는 것은 참조 카운트를 증가시킵니다</a></h3>
<p>예제 15-18의 작동하는 예제를 변경하여 <code>a</code> 내부의 <code>Rc&lt;List&gt;</code>에 대한
참조자가 생성되고 버려질 때 참조 카운트가 변하는 것을 볼 수 있도록 해봅시다.</p>
<p>예제 15-19에서는 <code>main</code>을 변경하여 안쪽의 스코프가 리스트 <code>c</code>를 감싸도록 하겠습니다;
그러면 <code>c</code>가 스코프 밖으로 벗어났을 때 참조 카운트가 어떻게 바뀌는지 볼 수 있습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
<p><span class="caption">예제 15-19: Printing the reference count</span></p>
<p>프로그램 내 참조 카운트가 변하는 각 지점에서 <code>Rc::strong_count</code>
함수를 호출하여 얻은 참조 카운트 값을 출력합니다. 이 함수가
<code>count</code>가 아니고 <code>strong_count</code>라는 이름이 된 이유는 <code>Rc&lt;T&gt;</code>
타입이 <code>weak_count</code>도 갖고 있기 때문입니다; <code>weak_count</code>가 뭘 위해서 사용되는지는
<a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">‘순환 참조 방지하기: <code>Rc&lt;T&gt;</code>를 <code>Weak&lt;T&gt;</code>로 바꾸기’</a><!-- ignore -->절에서
알아보겠습니다.</p>
<p>이 코드는 다음을 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p><code>a</code>의 <code>Rc&lt;List&gt;</code>는 초기 참조 카운트 1을 갖고 있음을 볼 수 있습니다;
그 후 <code>clone</code>을 호출할 때마다 카운트가 1씩 증가합니다. <code>c</code>가 스코프 밖으로
벗어날 때는 카운트가 1 감소합니다. <code>Rc::clone</code>를 호출하여 참조 카운트를
증가시켜야 했던 것과 달리 참조 카운트를 감소시키기 위해 어떤 함수를
호출할 필요는 없습니다: <code>Rc&lt;T&gt;</code> 값이 스코프 밖으로 벗어나면 <code>Drop</code>
트레이트의 구현체가 자동으로 참조 카운트를 감소시킵니다.</p>
<p><code>main</code>의 끝부분에서 <code>b</code>와 그다음 <code>a</code>가 스코프 밖을 벗어나서, 카운트가
0이 되고, 그 시점에서 <code>Rc&lt;List&gt;</code>가 완전히 메모리 정리되는 것은 이
예제에서 볼 수 없습니다. <code>Rc&lt;T&gt;</code>를 이용하면 단일 값이 복수 소유자를 갖도록
할 수 있고, 그 개수는 소유자 중 누구라도 계속 존재하는 한 해당 값이 계속
유효하도록 보장해 줍니다.</p>
<p><code>Rc&lt;T&gt;</code>는 불변 참조자를 통하여 읽기 전용으로 프로그램의 여러 부분에서
데이터를 공유하도록 해줍니다. 만일 <code>Rc&lt;T&gt;</code>가 여러 개의 가변 참조자도
만들도록 해준다면, 4장에서 논의했던 대여 규칙 중 하나를 위반할지도 모릅니다:
동일한 위치에서 여러 개의 가변 대여는 데이터 경합 및 데이터 불일치를
야기할 수 있습니다. 하지만 데이터의 변형을 가능하게 하는 것은 매우 유용하죠!
다음 절에서는 이러한 불변성 제약과 함께 동작하도록 하기 위한 내부 가변성
(interior mutability) 패턴 및 <code>Rc&lt;T&gt;</code>와 같이 결합하여 사용할 수 있는
<code>RefCell&lt;T&gt;</code> 타입에 대해 논의하겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-03-drop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-03-drop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-05-interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
