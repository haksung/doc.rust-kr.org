<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>순환 참조는 메모리 누수를 발생시킬 수 있습니다 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="순환-참조는-메모리-누수를-발생시킬-수-있습니다"><a class="header" href="#순환-참조는-메모리-누수를-발생시킬-수-있습니다">순환 참조는 메모리 누수를 발생시킬 수 있습니다</a></h2>
<p>러스트의 메모리 안정성 보장은 (<em>메모리 누수 (memory leak)</em> 라고도 알려져 있는) 뜻하지
않게 해제되지 않는 메모리를 생성하기 어렵게 만들지만, 불가능하게 만드는 것은 아닙니다.
메모리 누수를 완전히 방지하는 것은 러스트가 보장하는 것 중 하나가 아닌데, 이는 메모리
누수도 러스트에서는 메모리 안정성에 포함됨을 의미합니다. <code>Rc&lt;T&gt;</code> 및 <code>RefCell&lt;T&gt;</code>를
사용하면 러스트에서 메모리 누수가 허용되는 것을 알 수 있습니다: 즉 아이템들이 서로를
순환 참조하는 참조자를 만드는 것이 가능합니다. 이는 메모리 누수를 발생시키는데,
그 이유는 순환 고리 안의 각 아이템의 참조 카운트는 결코 0이 되지 않을 것이고,
그러므로 값들은 버려지지 않을 것이기 때문입니다.</p>
<h3 id="순환-참조-만들기"><a class="header" href="#순환-참조-만들기">순환 참조 만들기</a></h3>
<p>예제 15-25의 <code>List</code> 열거형과 <code>tail</code> 메서드 정의를 시작으로
어떻게 순환 참조가 생길 수 있고, 이를 어떻게 방지하는지
알아봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
<p><span class="caption">예제 15-25: <code>RefCell&lt;T&gt;</code>를 가지고 있어서
<code>Cons</code> 배리언트가 참조하는 것을 변경할 수 있는 cons 리스트 정의</span></p>
<p>예제 15-5의 <code>List</code> 정의의 또 다른 변형이 이용되고 있습니다.
이제 <code>Cons</code> 배리언트 내의 두 번째 요소는 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>인데,
이는 예제 15-24에서 했던 것처럼 <code>i32</code> 값을 변경하는 능력을 가진 대신,
<code>Cons</code> 배리언트가 가리키고 있는 <code>List</code> 값을 변경하길 원한다는 의미입니다.
또한 <code>tail</code> 메서드를 추가하여 <code>Cons</code> 배리언트를 갖고 있다면 두 번째 아이템에
접근하기 편하게 만들었습니다.</p>
<p>예제 15-26에서는 예제 15-25에서 사용한 <code>main</code> 함수를 추가하고 있습니다.
이 코드는 <code>a</code>에 리스트를 만들고 <code>b</code>에는 <code>a</code>의 리스트를 가리키고 있는 리스트를
만들어 넣었습니다. 그다음 <code>a</code>의 리스트가 <code>b</code>를 가리키도록 수정하는데, 이것이
순환 참조를 생성합니다. 이 과정에서 참조 카운트가 얼마인지 여러 곳에서 확인하기
위해 곳곳에 <code>println!</code> 구문들을 넣었습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
<p><span class="caption">예제 15-26: 두 개의 <code>List</code> 값이 서로를 가리키는
순환 참조 생성하기</span></p>
<p>초깃값 리스트 <code>5, Nil</code>을 가진 <code>List</code> 값을 갖는 <code>Rc&lt;List&gt;</code> 인스턴스를
만들어 <code>a</code> 변수에 넣었습니다. 그다음 <code>Rc&lt;List&gt;</code> 인스턴스에 만들어서 <code>b</code>에
넣었는데, 여기에는 10과 <code>a</code>의 리스트를 가리키고 있는 또 다른 <code>List</code> 값이
있습니다.</p>
<p><code>a</code>를 수정하여 이것이 <code>Nil</code> 대신 <code>b</code>를 가리키도록 하였는데, 이렇게 순환이
만들어집니다. 이는 <code>tail</code> 메서드를 사용하여 <code>a</code>에 있는 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>로부터
참조자를 얻어오는 식으로 이루어졌는데, 이것을 <code>link</code>라는 변수에 넣었습니다. 그다음
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>의 <code>borrow_mut</code> 메서드를 사용하여 <code>Nil</code> 값을 가지고 있는
<code>Rc&lt;List&gt;</code> 내부의 값을 <code>b</code>의 <code>Rc&lt;List&gt;</code>로 바꾸었습니다.</p>
<p>잠시 마지막 <code>println!</code> 문이 실행되지 않도록 주석 처리하고서 이 코드를 실행시키면
아래와 같은 출력을 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p><code>a</code>의 리스트가 <code>b</code>를 가리키도록 변경한 이후 <code>a</code>와 <code>b</code>의 <code>Rc&lt;List&gt;</code> 인스턴스의
참조 카운트는 둘 다 2입니다. <code>main</code>의 끝에서 러스트는 <code>b</code>를 버리는데, 이는
<code>b</code>의 <code>Rc&lt;List&gt;</code> 참조 카운트를 2에서 1로 줄입니다. <code>Rc&lt;List&gt;</code>가 힙에 보유한
메모리는 이 시점에서 해제되지 않을 것인데, 그 이유는 참조 카운트가 0이 아닌
1이기 때문입니다. 그런 다음 러스트는 <code>a</code>를 버리고, 이는 마찬가지로 <code>a</code>의
<code>Rc&lt;List&gt;</code> 인스턴스가 가진 참조 카운트를 2에서 1로 줄입니다. 이 인스턴스의
메모리 또한 버려질 수 없는데, 왜냐하면 이쪽의 <code>Rc&lt;List&gt;</code> 인스턴스도 여전히
무언가를 참조하기 때문입니다. 리스트에 할당된 메모리는 정리되지 않은 채
영원히 남을 것입니다. 이러한 순환 참조를 시각화하기 위해 그림 15-4의
다이어그램을 만들었습니다.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">그림 15-4: 리스트 <code>a</code>와 <code>b</code>가 서로를 가리키고
있는 순환 참조</span></p>
<p>만일 여러분이 마지막 <code>println!</code>의 주석을 해제하고 프로그램을 실행해 보면, 러스트는
<code>a</code>를 가리키고 있는 <code>b</code>를 가리키고 있는 <code>a</code>를 가리키고 있는 등등 스택 오버플로우가
날 때까지 이 순환을 출력하려 할 것입니다.</p>
<p>실제 프로그램과 비교했을 때 이 예제에서의 순환 참조 생성 결과는 그렇게까지
심각하진 않습니다: 순환 참조가 생성된 직후 프로그램이 종료되니까요.
하지만, 더 복잡한 프로그램이 많은 양의 메모리를 순환 참조하여 할당하고
오랜 시간 동안 이걸 가지고 있게 되면, 프로그램은 필요한 양보다 더 많은
메모리를 사용하게 되고 사용 가능한 메모리를 다 써버리게 되어 시스템을
멈추게 할지도 모릅니다.</p>
<p>순환 참조를 만드는 것은 쉽게 이루어지지는 않지만, 불가능한 것도 아닙니다.
만일 여러분이 <code>Rc&lt;T&gt;</code> 값을 가지고 있는 <code>RefCell&lt;T&gt;</code> 혹은 그와 유사하게
내부 가변성 및 참조 카운팅 기능이 있는 타입들의 중첩된 조합을 사용한다면,
여러분이 직접 순환을 만들지 않음을 보장해야 합니다; 이 순환을 찾아내는 것을
러스트에 의지할 수는 없습니다. 순환 참조를 만드는 것은 프로그램의 논리적
버그로서, 자동화된 테스트, 코드 리뷰, 그 외 소프트웨어 개발 연습 등을 통해
최소화해야 할 것입니다.</p>
<p>순환 참조를 피하는 또 다른 해결책은 데이터 구조를 재구성하여 어떤
참조자는 소유권을 갖고 어떤 참조자는 그렇지 않도록 하는 것입니다.
결과적으로 몇 개의 소유권 관계와 몇 개의 소유권 없는 관계로 이루어진
순환을 만들 수 있으며, 소유권 관계들만이 값을 버릴지 말지에 관해
영향을 주게 됩니다. 예제 15-25에서는 <code>Cons</code> 배리언트가 언제나
리스트를 소유하기를 원하므로, 데이터 구조를 재구성하는 것은 불가능합니다.
부모 노드와 자식 노드로 구성된 그래프를 이용한 예제를 살펴보면서
소유권 없는 관계가 순환 참조를 방지하는 적절한 방법이 되는 때가
언제인지 알아봅시다.</p>
<h3 id="순환-참조-방지하기-rct를-weakt로-바꾸기"><a class="header" href="#순환-참조-방지하기-rct를-weakt로-바꾸기">순환 참조 방지하기: <code>Rc&lt;T&gt;</code>를 <code>Weak&lt;T&gt;</code>로 바꾸기</a></h3>
<p>지금까지 <code>Rc::clone</code>을 호출하는 것은 <code>Rc&lt;T&gt;</code> 인스턴스의 <code>strong_count</code>를
증가시키고, <code>Rc&lt;T&gt;</code> 인스턴스는 자신의 <code>strong_count</code>가 0이 된 경우에만
제거되는 것을 보았습니다. <code>Rc::downgrade</code>에 <code>Rc&lt;T&gt;</code>의 참조자를 넣어서
호출하면 <code>Rc&lt;T&gt;</code> 인스턴스 내의 값을 가리키는 <em>약한 참조 (weak reference)</em> 를
만드는 것도 가능합니다. 강한 참조는 <code>Rc&lt;T&gt;</code> 인스턴스의 소유권을 공유할 수 있는
방법입니다. 약한 참조는 소유권 관계를 표현하지 않고, 약한 참조의 개수는
<code>Rc&lt;T&gt;</code> 인스턴스가 제거되는 경우에 영향을 주지 않습니다. 약한 참조가 포함된
순환 참조는 그 값의 강한 참조 개수를 0으로 만드는 순간 깨지게 되기 때문에,
순환 참조를 일으키지 않게 될 것입니다.</p>
<p><code>Rc::downgrade</code>를 호출하면 <code>Weak&lt;T&gt;</code> 타입의 스마트 포인터를 얻게 됩니다.
<code>Rc::downgrade</code>는 <code>Rc&lt;T&gt;</code> 인스턴스의 <code>strong_count</code>를 1 증가시키는
대신 <code>weak_count</code>를 1 증가시킵니다. <code>Rc&lt;T&gt;</code> 타입은 <code>strong_count</code>와
유사한 방식으로 <code>weak_count</code>를 사용하여 <code>Weak&lt;T&gt;</code> 참조가 몇 개 있는지
추적합니다. 차이점은 <code>Rc&lt;T&gt;</code> 인스턴스가 제거되기 위해 <code>weak_count</code>가
0일 필요는 없다는 것입니다.</p>
<p><code>Weak&lt;T&gt;</code>가 참조하고 있는 값이 이미 버려졌을지도 모르기 때문에, <code>Weak&lt;T&gt;</code>가
가리키고 있는 값으로 어떤 일을 하기 위해서는 그 값이 여전히 존재하는지를 반드시
확인해야 합니다. 이를 위해 <code>Weak&lt;T&gt;</code>의 <code>upgrade</code> 메서드를 호출하는데, 이 메서드는
<code>Option&lt;Rc&lt;T&gt;&gt;</code>를 반환할 것입니다. 만일 <code>Rc&lt;T&gt;</code> 값이 아직 버려지지 않았다면
<code>Some</code> 결과를 얻게 될 것이고 <code>Rc&lt;T&gt;</code> 값이 버려졌다면 <code>None</code> 결괏값을 얻게
될 것입니다. <code>upgrade</code>가 <code>Option&lt;T&gt;</code>를 반환하기 때문에, 러스트는 <code>Some</code>의
경우와 <code>None</code>의 경우가 반드시 처리되도록 할 것이고, 따라서 유효하지 않은 포인터는
없을 것입니다.</p>
<p>예제로 리스트처럼 어떤 아이템이 오직 다음 아이템에 대해서만 알고 있는 데이터 구조
말고, 자식 아이템 <em>그리고</em> 부모 아이템에 대해 모두 알고 있는 아이템을 갖는 트리를
만들어 보겠습니다.</p>
<h4 id="트리-데이터-구조-만들기-자식-노드를-가진-node"><a class="header" href="#트리-데이터-구조-만들기-자식-노드를-가진-node">트리 데이터 구조 만들기: 자식 노드를 가진 <code>Node</code></a></h4>
<p>자기 자식 노드에 대해 알고 있는 노드로 이루어진 트리를 만드는 것으로 시작해
보겠습니다. <code>i32</code>값과 함께 자식 <code>Node</code> 값들의 참조자들도 가지고 있는 <code>Node</code>라는
이름의 구조체를 만들겠습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p><code>Node</code>가 자기 자식들을 소유하도록 하고, 이 소유권을 공유하여 트리의 각
<code>Node</code>에 직접 접근할 수 있도록 하고 싶습니다. 이렇게 하기 위해 <code>Vec&lt;T&gt;</code>
아이템이 <code>Rc&lt;Node&gt;</code> 타입의 값이 되도록 정의하였습니다. 또한 어떤 노드가
다른 노드의 자식이 되도록 수정하려고 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>를 <code>RefCell&lt;T&gt;</code>로
감싼 <code>children</code>을 갖도록 하였습니다.</p>
<p>그다음 예제 15-27처럼 이 구조체 정의를 이용하여 3 값을 갖고 자식 노드가 없는
<code>leaf</code>라는 이름의 <code>Node</code> 인스턴스, 그리고 5 값과 <code>leaf</code>를 자식으로 갖는
<code>branch</code>라는 이름의 인스턴스를 만들도록 하겠습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
<p><span class="caption">예제 15-27: 자식이 없는 <code>leaf</code> 노드와
이 <code>leaf</code>를 자식으로 갖는 <code>branch</code> 노드 만들기</span></p>
<p><code>leaf</code>의 <code>Rc&lt;Node&gt;</code>를 복제하여 이를 <code>branch</code> 내에 저장했는데, 이는 <code>leaf</code>에
있는 <code>Node</code>의 소유자가 이제 둘이 되었다는 뜻입니다. <code>branch</code>로부터 <code>branch.children</code>를
통하여 <code>leaf</code>까지 접근할 수 있게 되었지만, <code>leaf</code>에서부터 <code>branch</code>로 접근할
방법은 없습니다. 그 원인은 <code>leaf</code>가 <code>branch</code>에 대한 참조자를 가지고 있지 않고
이들 간의 연관성을 알지 못하기 때문입니다. <code>leaf</code>에게 <code>branch</code>가 자신의 부모임을
알려주고 싶습니다. 이걸 다음에 해보겠습니다.</p>
<h4 id="자식에서-부모로-가는-참조자-추가하기"><a class="header" href="#자식에서-부모로-가는-참조자-추가하기">자식에서 부모로 가는 참조자 추가하기</a></h4>
<p>자식 노드가 그의 부모를 알도록 하기 위해서는 <code>parent</code> 필드를 <code>Node</code> 구조체
정의에 추가할 필요가 있겠습니다. 문제는 <code>parent</code>의 타입을 결정하는 데에
있습니다. 여기에 <code>Rc&lt;T&gt;</code>를 넣게 되면 <code>branch</code>를 가리키고 있는 <code>leaf.parent</code>와
<code>leaf</code>를 가리키고 있는 <code>branch.children</code>으로 이루어진 순환 참조를 만들게 되며,
이들의 <code>strong_count</code>값을 결코 0이 되지 않게 하는 원인을 제공할 것이기 때문에,
여기에 <code>Rc&lt;T&gt;</code>를 사용할 수 없음을 알고 있습니다.</p>
<p>이 관계들을 다른 방식으로 생각해 보면, 부모 노드는 그의 자식들을 소유해야 합니다:
즉 만일 부모 노드가 버려지게 되면, 그의 자식 노드들도 또한 버려져야 합니다.
하지만, 자식은 그의 부모를 소유해서는 안 됩니다: 즉 자식 노드가 버려지더라도
그 부모는 여전히 존재해야 합니다. 이것이 바로 약한 참조를 위한 경우입니다!</p>
<p>따라서 <code>Rc&lt;T&gt;</code> 대신 <code>Weak&lt;T&gt;</code>를 이용하여, 특별히 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>를
이용하여 <code>parent</code>의 타입을 만들겠습니다. 이제 <code>Node</code> 구조체 정의는 아래와
같이 생겼습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>노드는 자신의 부모 노드를 참조할 수 있게 되겠지만 그 부모를 소유하지는 않습니다.
예제 15-28에서는 <code>main</code>을 업데이트하여 이 새로운 정의를 사용하도록 해서 <code>leaf</code>
노드가 자기 부모인 <code>branch</code>를 참조할 수 있는 방법을 갖도록 합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
<p><span class="caption">예제 15-28: 부모 노드 <code>branch</code>의 약한 참조를
갖는 <code>leaf</code> 노드</span></p>
<p><code>leaf</code> 노드를 만드는 것이 <code>parent</code> 필드를 제외하고는 예제 15-27과
비슷해 보입니다: <code>leaf</code>는 부모 없이 시작돼서, 새 비어있는 <code>Weak&lt;Node&gt;</code>
참조자 인스턴스를 생성하였습니다.</p>
<p>이 시점에서 <code>upgrade</code> 메서드를 사용하여 <code>leaf</code>의 부모에 대한 참조자를
얻는 시도를 하면 <code>None</code> 값을 얻습니다. 첫 번째 <code>println!</code> 구문에서는
아래와 같은 출력을 보게 됩니다:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p><code>branch</code> 노드를 생성할 때도 <code>parent</code> 필드에 새로운 <code>Weak&lt;Node&gt;</code>
참조자를 넣었는데, 이는 <code>branch</code>에게는 부모 노드가 없기 때문입니다.
<code>leaf</code>는 여전히 <code>branch</code>의 자식 중 하나입니다. 일단 <code>branch</code>의 <code>Node</code>
인스턴스를 갖게 되면, <code>leaf</code>를 수정하여 자기 부모에 대한 <code>Weak&lt;Node&gt;</code>
참조자를 갖도록 할 수 있습니다. <code>leaf</code>의 <code>parent</code> 필드의
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>에 있는 <code>borrow_mut</code> 메서드를 사용하고, 그런 다음
<code>Rc::downgrade</code> 함수를 사용하여 <code>branch</code>의 <code>Rc&lt;Node&gt;</code>로부터 <code>branch</code>에
대한 <code>Weak&lt;Node&gt;</code> 참조자를 생성하였습니다.</p>
<p><code>leaf</code>의 부모를 다시 한번 출력할 때는 <code>branch</code>를 가지고 있는 <code>Some</code> 배리언트를
얻게 될 것입니다: 이제 <code>leaf</code>는 자기 부모에 접근할 수 있습니다! <code>leaf</code>를 출력할
때 예제 15-26에서와 같이 궁극적으로 스택 오버플로우로 끝나버리는 그 순환 문제도
피하게 되었습니다; <code>Weak&lt;Node&gt;</code> 참조자는 <code>(Weak)</code>로 출력됩니다:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>무한 출력이 없다는 것은 이 코드가 순환 참조를 생성하지 않았음을 나타냅니다.
또한 <code>Rc::strong_count</code>와 <code>Rc::weak_count</code>를 호출하여 얻은 값을 살펴보는
것으로도 알 수 있습니다.</p>
<h4 id="strong_count와-weak_count의-변화를-시각화하기"><a class="header" href="#strong_count와-weak_count의-변화를-시각화하기"><code>strong_count</code>와 <code>weak_count</code>의 변화를 시각화하기</a></h4>
<p>새로운 내부 스코프를 만들고 <code>branch</code>의 생성 과정을 이 스코프로 옮겨서
<code>Rc&lt;Node&gt;</code> 인스턴스의 <code>strong_count</code>와 <code>weak_count</code> 값이 어떻게
변하는지 살펴봅시다. 그렇게 하면 <code>branch</code>가 만들어질 때와, 그 후 스코프
밖으로 벗어났을 때 어떤 일이 생기는지 알 수 있습니다. 수정본은
예제 15-29와 같습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
<p><span class="caption">예제 15-29: 내부 스코프에서 <code>branch</code>를 만들고
강한 참조 카운트와 약한 참조 카운트 시험하기</span></p>
<p><code>leaf</code>가 생성된 다음, 이것의 <code>Rc&lt;Node&gt;</code>는 강한 참조 카운트 1개와 약한 참조 카운트
0개를 갖습니다. 내부 스코프에서 <code>branch</code>를 만들고 <code>leaf</code>와 연관짓게 되는데,
이때 카운트를 출력하면 <code>branch</code>의 <code>Rc&lt;Node&gt;</code>는 강한 참조 카운트 1개와
(<code>Weak&lt;Node&gt;</code>로 <code>branch</code>를 가리키는 <code>leaf.parent</code>에 대한) 약한 참조 카운트
1개를 갖고 있을 것입니다. <code>leaf</code> 내의 카운트를 출력하면 강한 참조 카운트 2개를
갖고 있음을 보게 될 것인데, 이는 <code>branch</code>가 이제 <code>branch.children</code>에 저장된
<code>leaf</code>의 <code>Rc&lt;Node&gt;</code>에 대한 클론을 가지게 되었지만, 약한 참조는 여전히 0개이기
때문입니다.</p>
<p>내부 스코프가 끝나게 되면, <code>branch</code>는 스코프 밖으로 벗어나게 되고 <code>Rc&lt;Node&gt;</code>의
강한 참조 카운트는 0으로 줄어들게 되므로, 이것의 <code>Node</code>는 버려집니다.
<code>leaf.parent</code>의 약한 참조 카운트 1개는 <code>Node</code>가 버려질지 말지와는
아무런 관계가 없으므로, 아무런 메모리 누수도 발생하지 않습니다!</p>
<p>만일 이 스코프의 끝부분 뒤에 <code>leaf</code>의 부모에 접근 시도를 한다면 다시 <code>None</code>을
얻게 될 것입니다. 프로그램의 끝부분에서, <code>leaf</code>의 <code>Rc&lt;Node&gt;</code>는 강한 참조
카운트 1개와 약한 참조 카운트 0개를 갖고 있는데, 이제 <code>leaf</code> 변수가 다시
<code>Rc&lt;Node&gt;</code>에 대한 유일한 참조자이기 때문입니다.</p>
<p>참조 카운트와 값 버리기를 관리하는 모든 로직은 <code>Rc&lt;T&gt;</code>와 <code>Weak&lt;T&gt;</code>,
그리고 이들의 <code>Drop</code> 트레이트에 대한 구현부에 만들어져 있습니다.
자식과 부모의 관계가 <code>Weak&lt;T&gt;</code> 참조자로 있어야 함을 <code>Node</code>의
정의에 특정함으로써, 여러분은 순환 참조와 메모리 누수를 만들지
않으면서 자식 노드를 가리키는 부모 노드 혹은 그 반대의 것을 만들
수 있습니다.</p>
<h2 id="정리"><a class="header" href="#정리">정리</a></h2>
<p>이번 장에서는 러스트가 일반적인 참조자를 가지고 기본적으로 보장하는 것들과는
다른 보장과 절충안을 만들어 내기 위해 스마트 포인터를 사용하는 방법을
다루었습니다. <code>Box&lt;T&gt;</code> 타입은 알려진 크기를 갖고 있고 힙에 할당된 데이터를
가리킵니다. <code>Rc&lt;T&gt;</code> 타입은 힙에 있는 데이터에 대한 참조자의 개수를 추적하여
그 데이터가 여러 개의 소유자를 가질 수 있도록 합니다. 내부 가변성을 갖춘
<code>RefCell&lt;T&gt;</code> 타입은 불변 타입이 필요하지만 그 타입의 내부 값을 변경할 필요가
있을 때 사용할 수 있습니다; 이것은 또한 컴파일 타임 대신 런타임에 대여 규칙을
따르도록 강제합니다.</p>
<p>또한 <code>Deref</code> 및 <code>Drop</code> 트레이트를 다루었는데, 이는 스마트 포인터의 수많은
기능을 활성화해 줍니다. 메모리 누수를 발생시킬 수 있는 순환 참조와, <code>Weak&lt;T&gt;</code>을
이용하여 이를 방지하는 방법도 탐구하였습니다.</p>
<p>이번 장이 여러분의 흥미를 자극하여 직접 여러분만의 스마트 포인터를
구현하고 싶어졌다면, <a href="https://doc.rust-lang.org/nomicon/index.html">‘러스토노미콘’</a>에서 더 유용한 정보를
확인하세요.</p>
<p>다음에는 러스트의 동시성에 대해 이야기해 보겠습니다. 심지어 몇 가지 새로운
스마트 포인터에 대해서도 배우게 될 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
