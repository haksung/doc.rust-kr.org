<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>참조와 대여 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="참조와-대여"><a class="header" href="#참조와-대여">참조와 대여</a></h2>
<p>앞 절 마지막에 등장한 예제 4-5에서는 <code>String</code>이 <code>calculate_length</code>로
이동해 버린 것 때문에 <code>calculate_length</code>를 호출한 함수로 <code>String</code>을
반환하여, 함수 호출 이후에도 <code>String</code>을 사용할 수 있게 하였습니다.
이렇게 하는 대신 <code>String</code> 값의 참조자를 만들 수 있습니다.
<em>참조자 (reference)</em> 는 해당 주소에 저장된 데이터에 접근할 수 있도록
해주는 주솟값에 해당하는, 포인터와 같은 것입니다; 그 데이터는 다른 어떤
변수가 소유하고 있죠. 포인터와는 달리, 참조자는 살아있는 동안 특정 타입에
대한 유효한 값을 가리킴을 보장해 줍니다.</p>
<p>이번에는 값의 소유권을 넘기는 대신 개체의 참조자를 넘겨주는 방법을 소개하도록 하겠습니다.
다음은 참조자를 매개변수로 받도록 구현한 <code>calculate_length</code> 함수의 정의 및 용례입니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>먼저, 변수 선언부와 함수 반환 값에 위치하던 튜플 코드가 전부 사라진
것을 볼 수 있습니다. 또한 <code>calculate_length</code> 함수에 <code>s1</code> 대신 <code>&amp;s1</code>을
전달하고, 함수 정의에 <code>String</code> 대신 <code>&amp;String</code>을 사용했네요. 이 앰퍼센드
(&amp;) 기호가 <em>참조자</em>를 나타내고, 어떤 값의 소유권을 가져오지 않고 해당 값을
참조할 수 있도록 해 줍니다. 그림 4-5는 이 개념을 도식화한 것입니다.</p>
<p><img alt="세 개의 테이블: s 테이블은 s1 테이블을 가리키는 포인터만
가지고 있습니다. s1 테이블에는 s1에 대한 스택 데이터와 힙 상에 저장된
문자열을 가리키고 있습니다." src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">그림 4-5: <code>&amp;String s</code>는  <code>String s1</code>을
가리킴</span></p>
<blockquote>
<p>Note: <code>&amp;</code>를 이용한 참조의 반대는
<em>역참조 (dereferencing)</em> 라 합니다.
역참조 기호는 <code>*</code>이며, 8장에서 몇 번 다뤄보고
15장에서 자세한 내용을 배울 예정입니다.</p>
</blockquote>
<p>함수 호출부를 좀 더 자세히 살펴봅시다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("The length of '{}' is {}.", s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>s1</code>에 <code>&amp;</code>를 붙인 <code>&amp;s1</code> 구문은 <code>s1</code> 값을 참조하지만 해당 값을 소유하지
않는 참조자를 생성합니다. 값을 소유하지 않으므로 이 참조자가 가리킨 값은
참조자가 사용되지 않을 때까지 버려지지 않습니다.</p>
<p>마찬가지로 함수 시그니처에도 <code>&amp;</code>를 사용하여 매개변수 <code>s</code>가 참조자 타입임을
나타내줍니다. 주석으로 보여드리겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("The length of '{}' is {}.", s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s는 String의 참조자입니다
    s.len()
} // 여기서 s가 스코프 밖으로 벗어납니다. 하지만 참조하는 것을 소유하고 있진 않으므로,
  // 버려지지는 않습니다.</code></pre></pre>
<p>변수 <code>s</code>가 유효한 스코프는 여타 함수의 매개변수에 적용되는
스코프와 동일합니다. 하지만 <code>s</code>에는 소유권이 없으므로 <code>s</code>가
더 이상 사용되지 않을 때도 이 참조자가 가리킨 값이 버려지지
않습니다. 함수가 실제 값 대신 참조자를 매개변수로 쓴다면
애초에 소유권이 없으니까 이 소유권을 돌려주기 위한 값 반환도
필요 없어집니다.</p>
<p>또한, 이처럼 참조자를 만드는 행위를 <em>대여 (borrow)</em> 라고 합니다.
현실에서도 여러분이 다른 사람이 소유하고 있는 뭔가를 빌리고,
용무가 끝나면 돌려주는 것처럼요. 여러분의 소유가 아니니까요.</p>
<p>그럼 빌린 값을 수정하면 어떻게 될까요? 예제 4-6 코드를
실행해 보면 알 수 있으나, 미리 말씀드리자면 이 코드는 작동하지 않습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
<p><span class="caption">예제 4-6: 빌린 값을 수정해 보는 코드</span></p>
<p>나타나는 에러는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>변수가 기본적으로 불변성을 지니듯,
참조자도 마찬가지로 참조하는 것을 수정할 수 없습니다.</p>
<h3 id="가변-참조자"><a class="header" href="#가변-참조자">가변 참조자</a></h3>
<p><em>가변 참조자 (mutable reference)</em> 를 사용하는 식으로 예제 4-6을 살짝만
수정하면 에러를 없앨 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
<p>우선 <code>s</code>를 <code>mut</code> 로 변경합니다. 그런 다음 <code>change</code> 함수를 호출하는 곳에서
<code>&amp;mut s</code>로 가변 참조자를 생성하고, 이 함수에서 가변 참조자를 전달받도록
<code>some_string: &amp;mut String</code>으로 수정합니다. 이는 <code>change</code> 함수가
빌린 값을 수정할 수 있음을 매우 명확하게 해 줍니다.</p>
<p>가변 참조자는 한 가지 큰 제약사항이 있습니다: 어떤 값에 대한 가변 참조자가
있다면, 그 값에 대한 참조자는 더 이상 만들 수 없습니다. 아래의 코드는
<code>s</code>에 대한 두 개의 가변 참조자 생성을 시도하는 코드로, 작동하지 않습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
<span class="boring">}</span></code></pre>
<p>에러는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>이 에러는 <code>s</code>를 가변으로 두 번 이상 빌려올 수 없기 때문에 코드가
유효하지 않다고 말해줍니다. 첫 번째 가변 대여는 <code>r1</code>에 있고,
<code>println!</code>에서 사용될 때까지 남아있어야 하지만, 이 가변 참조자의
생성과 사용 사이에서 <code>r1</code>과 같은 데이터를 빌리는 <code>r2</code>의 가변 참조자를
만들고 있습니다.</p>
<p>같은 데이터에 대하여 동시에 여러 가변 참조자의 사용을 막는 이러한
제약은 값의 변경에 대한 제어가 원활하도록 해 줍니다. 대부분의 언어들이
언제든 값 변경을 허용하기 때문에, 러스트에 갓 입문한 사람들에게는 장애물처럼
다가올 수 있습니다. 하지만, 이 제약 덕분에 러스트에서는 컴파일 타임에
<em>데이터 경합 (data race)</em> 을 방지할 수 있습니다. 데이터 경합이란 다음
세 가지 상황이 겹칠 때 일어나는 특정한 경합 조건 (race condition) 입니다:</p>
<ul>
<li>둘 이상의 포인터가 동시에 같은 데이터에 접근</li>
<li>포인터 중 하나 이상이 데이터에 쓰기 작업을 시행</li>
<li>데이터 접근 동기화 메커니즘이 없음</li>
</ul>
<p>데이터 경합은 정의되지 않은 동작을 일으키며, 런타임에 추적하려고 할 때
문제 진단 및 수정이 어렵습니다. 하지만 러스트에서는 데이터 경합이 발생할
가능성이 있는 코드의 컴파일을 거부하는 것으로 이 문제를 막아줍니다!</p>
<p>중괄호로 새로운 스코프를 만들어, 가변 참조자를 여러 개 만들면서 <em>동시에</em>
존재하는 상황을 회피하는 방법이 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // 여기서 r1이 스코프 밖으로 벗어나며, 따라서 아무 문제없이 새 참조자를 만들 수 있습니다.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>가변 참조자와 불변 참조자를 혼용할 때도 유사한 규칙이 적용됩니다.
다음 코드는 컴파일 에러가 발생합니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // 문제없음
    let r2 = &amp;s; // 문제없음
    let r3 = &amp;mut s; // 큰 문제

    println!("{}, {}, and {}", r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>에러는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>휴우! 어떤 값에 대한 불변 참조자가 있는 동안 같은 값의 가변 참조자를 만드는 것
<em>또한</em> 불가능합니다.</p>
<p>불변 참조자를 사용하는 쪽에서는 사용 중 값이 중간에 변경되리라
예상하지 않으니까요. 반면 데이터를 읽기만 하는 기능으로는 다른 쪽에서
값을 읽는 기능에 영향을 주지 않으므로, 여러 개의 불변 참조자를 만드는 것은
가능합니다.</p>
<p>참조자는 정의된 지점부터 시작하여 해당 참조자가 마지막으로
사용된 부분까지 유효합니다. 즉, 다음 코드는 불변 참조자가 마지막으로
사용되는 <code>println!</code> 이후에 가변 참조자의 정의가 있으므로 컴파일 에러가
발생하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // 문제없음
    let r2 = &amp;s; // 문제없음
    println!("{} and {}", r1, r2);
    // 이 지점 이후로 변수 r1과 r2는 사용되지 않습니다

    let r3 = &amp;mut s; // 문제없음
    println!("{}", r3);
<span class="boring">}</span></code></pre></pre>
<p>불변 참조자 <code>r1</code>, <code>r2</code>의 스코프는 자신들이 마지막으로 사용된
<code>println!</code> 이후로 종료되고, 해당 <code>println!</code>은  가변 참조자 <code>r3</code>가
생성되기 전이니 서로 스코프가 겹치지 않아서 이 코드는 문제가 없는 것이죠:
컴파일러는 이 참조자가 어떤 지점 이후로 스코프 끝까지 사용되지 않음을
알 수 있습니다.</p>
<p>이러한 제약 때문에 좀 골치 아플 수도 있습니다만, 이는 러스트 컴파일러가
코드에 숨어 있는 버그를 런타임이 아닌 컴파일 타임에 일찌감치 찾아내어
어느 부분이 문제인지 정확히 집어주는 기능이란 점을 기억해주세요. 이렇게
하면 원하는 데이터가 나오지 않는 원인을 하나하나 추적하지 않아도 됩니다.</p>
<h3 id="댕글링-참조"><a class="header" href="#댕글링-참조">댕글링 참조</a></h3>
<p><em>댕글링 포인터 (dangling pointer)</em> 란, 어떤 메모리를 가리키는
포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써,
다른 개체가 할당받았을지도 모르는 메모리를 참조하게 된 포인터를 말합니다.
포인터가 있는 언어에서는 자칫 잘못하면 이 댕글링 포인터를 만들기 쉽죠.
하지만 러스트에서는 어떤 데이터의 참조자를 만들면, 해당 참조자가 스코프를
벗어나기 전에 데이터가 먼저 스코프를 벗어나는지 컴파일러에서 확인하여
댕글링 참조가 생성되지 않도록 보장합니다.</p>
<p>댕글링 참조를 만들어서 러스트가 어떤 식으로 이것을 컴파일 타임에
방지하는지 살펴봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
<p>에러는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>아직 다루지 않은 라이프타임이라는 내용이 에러 메시지에 등장하는데,
라이프타임은 10장에서 다룰 예정이니 일단 무시하도록 하겠습니다.
이 코드가 문제가 되는 이유를 알려주는 핵심 내용은 다음과 같습니다:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value for it to be borrowed from.
(해석: 이 함수는 빌린 값을 반환하고 있으나, 빌린 실제 값이 존재하지 않습니다.)
</code></pre>
<p><code>dangle</code> 함수에서 어떤 일이 일어나는지
단계별로 알아봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle은 String의 참조자를 반환합니다

    let s = String::from("hello"); // s는 새로운 String입니다

    &amp;s // String s의 참조자를 반환합니다
} // 여기서 s는 스코프 밖으로 벗어나고 버려집니다. 해당 메모리는 해제됩니다.
  // 위험합니다!</code></pre>
<p><code>s</code>는  <code>dangle</code> 함수 내에서 생성됐기 때문에,
함수가 끝날 때 할당 해제됩니다.
하지만 코드에서는 <code>&amp;s</code>를 반환하려 했고, 이는 유효하지 않은 <code>String</code>을 가리키는
참조자를 반환하는 행위이기 때문에 에러가 발생합니다.</p>
<p>따라서, 이런 경우엔 <code>String</code>을 직접 반환해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>이 코드는 정상적으로 작동합니다.
소유권은 이동되며, 할당 해제되지도 않죠.</p>
<h3 id="참조자-규칙"><a class="header" href="#참조자-규칙">참조자 규칙</a></h3>
<p>참조자에 대해 배운 내용을 정리해 봅시다:</p>
<ul>
<li>여러분은 단 하나의 가변 참조자만 갖거나,
여러 개의 불변 참조자를 가질 수 있습니다.</li>
<li>참조자는 항상 유효해야 합니다.</li>
</ul>
<p>다음으로 알아볼 것은 참조자의 또 다른 종류인 슬라이스 (slice) 입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-01-what-is-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-03-slices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-01-what-is-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-03-slices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
