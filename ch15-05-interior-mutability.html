<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt;와 내부 가변성 패턴 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-kr/doc.rust-kr.org" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt와-내부-가변성-패턴"><a class="header" href="#refcellt와-내부-가변성-패턴"><code>RefCell&lt;T&gt;</code>와 내부 가변성 패턴</a></h2>
<p><em>내부 가변성 (interior mutability)</em> 은 어떤 데이터에 대한 불변 참조자가 있을
때라도 데이터를 변경할 수 있게 해주는 러스트의 디자인 패턴입니다; 보통 이러한
동작은 대여 규칙에 의해 허용되지 않습니다. 데이터를 변경하기 위해서, 이 패턴은
데이터 구조 내에서 <code>unsafe</code> (안전하지 않은) 코드를 사용하여 변경과 대여를 지배하는
러스트의 일반적인 규칙을 우회합니다. 안전하지 않은 코드는 이 규칙들을 지키고 있는지에
대한 검사를 컴파일러에게 맡기는 대신 수동으로 하는 중임을 컴파일러에게 알립니다;
안전하지 않은 코드에 대해서는 19장에서 더 알아보겠습니다.</p>
<p>컴파일러는 대여 규칙을 준수함을 보장할 수 없을지라도, 우리가 이를
런타임에 보장할 수 있는 경우라면 내부 가변성 패턴을 쓰는 타입을
사용할 수 있습니다. 여기에 포함된 <code>unsafe</code> 코드는 안전한 API로
감싸져 있고, 바깥쪽 타입은 여전히 불변입니다.</p>
<p>내부 가변성 패턴을 따르는 <code>RefCell&lt;T&gt;</code> 타입을 살펴보면서 이 개념을
탐구해 봅시다.</p>
<h3 id="refcellt으로-런타임에-대여-규칙-집행하기"><a class="header" href="#refcellt으로-런타임에-대여-규칙-집행하기"><code>RefCell&lt;T&gt;</code>으로 런타임에 대여 규칙 집행하기</a></h3>
<p><code>Rc&lt;T&gt;</code>와는 다르게, <code>RefCell&lt;T&gt;</code> 타입은 가지고 있는 데이터에 대한 단일 소유권을
나타냅니다. 그렇다면, <code>Box&lt;T&gt;</code>와 같은 타입과 <code>RefCell&lt;T&gt;</code>의 다른 부분은
무엇일까요? 4장에서 배웠던 대여 규칙을 상기해 봅시다:</p>
<ul>
<li>어떠한 경우이든 간에, 하나의 가변 참조자 혹은 여러 개의 불변 참조자 중
(둘 다가 아니고) 하나<em>만</em> 가질 수 있습니다.</li>
<li>참조자는 항상 유효해야 합니다.</li>
</ul>
<p>참조자와 <code>Box&lt;T&gt;</code>를 이용할 때, 대여 규칙의 불변성은 컴파일 타임에 집행됩니다.
<code>RefCell&lt;T&gt;</code>를 이용할 때, 이 불변성은 <em>런타임에</em> 집행됩니다. 참조자를 가지고서
이 규칙을 어기면 컴파일러 에러를 얻게 될 것입니다. <code>RefCell&lt;T&gt;</code>를 가지고서
여러분이 이 규칙을 어기면, 프로그램은 <code>panic!</code>을 일으키고 종료될 것입니다.</p>
<p>컴파일 타임의 대여 규칙 검사는 개발 과정에서 에러를 더 일찍 잡을 수
있다는 점, 그리고 이 모든 분석이 사전에 완료되기 때문에 런타임 성능에
영향이 없다는 장점이 있습니다. 이러한 이유로 컴파일 타임의 대여 규칙을
검사하는 것이 대부분의 경우에서 가장 좋은 선택이고, 이것이 러스트의
기본 설정인 이유이기도 합니다.</p>
<p>런타임의 대여 규칙 검사를 하면 컴파일 타임 검사에 의해서는
허용되지 않을 특정 메모리 안정성 시나리오가 허용된다는 장점이
있습니다. 러스트 컴파일러와 같은 정적 분석은 태생적으로 보수적입니다.
어떤 코드 속성은 코드 분석으로는 발견이 불가능합니다: 가장 유명한
예제로 정지 문제 (halting problem) 가 있는데, 이는 이 책의 범위를
벗어나지만 연구하기에 흥미로운 주제입니다.</p>
<p>몇몇 분석이 불가능하기 때문에, 러스트 컴파일러가 어떤 코드의 소유권
규칙 준수를 확신할 수 없다면, 올바른 프로그램을 거부할지도 모릅니다;
이런 식으로 컴파일러는 보수적입니다. 러스트가 올바르지 않은 프로그램을
수용한다면, 사용자들은 러스트가 보장하는 것을 신뢰할 수 없을 것입니다.
하지만, 만일 러스트가 올바른 프로그램을 거부한다면, 프로그래머는 불편하겠지만
어떠한 재앙도 일어나지 않을 수 있습니다. <code>RefCell&lt;T&gt;</code> 타입은 여러분의 코드가
대여 규칙을 준수한다는 것을 컴파일러는 이해하거나 보장할 수 없지만
여러분이 확신하는 경우 유용합니다.</p>
<p><code>Rc&lt;T&gt;</code>와 유사하게, <code>RefCell&lt;T&gt;</code>은 싱글스레드 시나리오 내에서만 사용
가능하고, 멀티스레드 컨텍스트에서 사용을 시도할 경우에는 컴파일 타임 에러를
낼 것입니다. <code>RefCell&lt;T&gt;</code>의 기능을 멀티스레드 프로그램에서 사용하는
방법에 대해서는 16장에서 이야기하겠습니다.</p>
<p><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, 혹은 <code>RefCell&lt;T&gt;</code>을 선택하는 이유의 요점을 정리하면 다음과 같습니다:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>는 동일한 데이터에 대해 복수 소유자를 가능하게 합니다; <code>Box&lt;T&gt;</code>와
<code>RefCell&lt;T&gt;</code>은 단일 소유자만 갖습니다.</li>
<li><code>Box&lt;T&gt;</code>는 컴파일 타임에 검사 되는 불변 혹은 가변 대여를 허용합니다; <code>Rc&lt;T&gt;</code>는
오직 컴파일 타임에 검사 되는 불변 대여만 허용합니다; <code>RefCell&lt;T&gt;</code>는 런타임에
검사되는 불변 혹은 가변 대여를 허용합니다.</li>
<li><code>RefCell&lt;T&gt;</code>이 런타임에 검사 되는 가변 대여를 허용하기 때문에,
<code>RefCell&lt;T&gt;</code>이 불변일 때라도 <code>RefCell&lt;T&gt;</code> 내부의 값을 변경할
수 있습니다.</li>
</ul>
<p>불변값 내부의 값을 변경하는 것이 <em>내부 가변성</em> 패턴입니다.
내부 가변성이 유용한 경우를 살펴보고 이것이 어떻게 가능한지
조사해 봅시다.</p>
<h3 id="내부-가변성-불변값에-대한-가변-대여"><a class="header" href="#내부-가변성-불변값에-대한-가변-대여">내부 가변성: 불변값에 대한 가변 대여</a></h3>
<p>대여 규칙의 결과로 불변값을 가지고 있을 때 이걸 가변으로 빌려올 수는
없습니다. 예를 들면, 다음 코드는 컴파일되지 않을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>이 코드를 컴파일 시도하면, 다음과 같은 에러를 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<p>하지만, 어떤 값이 자신의 메서드 내부에서는 변경되지만 다른 코드에서는
불변으로 보이게 하는 것이 유용한 경우가 있습니다. 그 값의 메서드 바깥쪽
코드에서는 값을 변경할 수 없을 것입니다. <code>RefCell&lt;T&gt;</code>을 이용하는 것이
내부 가변성의 기능을 얻는 한 가지 방법이지만, <code>RefCell&lt;T&gt;</code>이 대여
규칙을 완벽하게 피하는 것은 아닙니다: 컴파일러의 대여 검사기는
이러한 내부 가변성을 허용하고, 대신 대여 규칙은 런타임에 검사 됩니다.
만일 이 규칙을 위반하면, 컴파일러 에러 대신 <code>panic!</code>을 얻을
것입니다.</p>
<p><code>RefCell&lt;T&gt;</code>를 이용하여 불변값을 변경할 수 있는 실질적인 예제를
실습해보고 이것이 왜 유용한지를 알아봅시다.</p>
<h4 id="내부-가변성에-대한-용례-목-객체"><a class="header" href="#내부-가변성에-대한-용례-목-객체">내부 가변성에 대한 용례: 목 객체</a></h4>
<p>테스트 중 종종 프로그래머는 어떤 타입 대신 다른 타입을 사용하게 되는데,
이를 통해 특정 동작을 관측하고 정확하게 구현되었음을 단언하기 위한 것입니다.
이러한 자리 표시형 타입을 <em>테스트 더블 (test double)</em> 이라고 합니다. 영화 제작에서
‘스턴트 더블 (stunt double)’이라고 부르는, 어떤 사람이 나서서 배우를 대신해 특정한
어려운 장면을 수행하는 것과 같은 의미로 생각하시면 됩니다. 테스트 더블은 테스트를
수행할 때 다른 타입 대신 나서는 것이죠. <em>목 객체 (mock object)</em> 는
테스트 더블의 특정한 형태로서 테스트 중 어떤 일이 일어났는지 기록하여 정확한
동작이 일어났음을 단언할 수 있도록 해줍니다.</p>
<p>러스트에는 다른 언어들에서의 객체와 동일한 의미의 객체가 없고,
러스트에는 몇몇 다른 언어들처럼 표준 라이브러리에 미리 만들어진
목 객체 기능이 없습니다. 하지만, 당연하게도 목 객체로서 동일한
목적을 제공할 구조체를 만들 수 있습니다.</p>
<p>여기서 테스트하려는 시나리오는 다음과 같습니다: 최댓값을 기준으로 어떤 값을
추적하여 현재 값이 최댓값에 얼마나 근접했는지에 대한 메시지를 전송하는
라이브러리를 만들려고 합니다. 이를테면 이 라이브러리는 한 명의 사용자에게
허용되고 있는 API 호출 수의 허용량을 추적하는 데 사용될 수 있습니다.</p>
<p>우리의 라이브러리는 어떤 값이 최댓값에 얼마나 근접했는지를 추적하고 어떤 메시지를
언제 보내야 할지에 대한 기능만 제공할 것입니다. 이 라이브러리를 사용하는 애플리케이션이
메시지를 전송하는 것에 대한 메커니즘을 제공할 예정입니다: 이 애플리케이션은 메시지를
애플리케이션 내에 집어넣거나, 이메일을 보내거나, 문자 메시지를 보내거나, 혹은 그
밖의 것들을 할 수 있습니다. 라이브러리는 그런 자세한 사항을 알 필요가 없습니다.
필요한 모든 것은 우리가 제공하게 될 <code>Messenger</code>라는 이름의 트레이트를 구현하는 것입니다.
예제 15-20은 라이브러리 코드를 보여줍니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
<p><span class="caption">예제 15-20: 어떤 값이 최댓값에 얼마나 근접하는지를
추적하고 특정 수준에 값이 있으면 경고해 주는 라이브러리</span></p>
<p>이 코드에서 한 가지 중요한 부분은 <code>Messenger</code> 트레이트가 <code>self</code>에 대한
불변 참조자와 메시지의 텍스트를 인수로 갖는 <code>send</code>라는 메서드 하나를 갖고
있다는 것입니다. 이 트레이트는 목 객체가 실제 오브젝트와 동일한 방식으로 사용될
수 있도록 하기 위해 구현해야 하는 인터페이스입니다. 그 외에 중요한
부분은 <code>LimitTracker</code> 상의 <code>set_value</code> 메서드의 동작을 테스트해야
한다는 점입니다. <code>value</code> 매개변수에 어떤 것을 넘길지 바꿀 수는
있지만, <code>set_value</code>는 단언에 필요한 어떤 것도 반환하지 않습니다.
<code>Messenger</code> 트레이트를 구현한 어떤 것과 <code>max</code>에 대한 특정 값과 함께
<code>LimitTracker</code>를 만든다면, <code>value</code>에 대해 다른 숫자들을 넘겼을 때
메신저가 적합한 메시지를 보냈다고 말할 수 있길 원하는 것이죠.</p>
<p><code>send</code>를 호출했을 때 메일이나 텍스트 메시지를 보내는 대신, 보냈다고
언급하는 메시지만 추적할 목 객체가 필요합니다. 목 객체의 새 인스턴스를
생성하고, 이 목 객체를 사용하는 <code>LimitTracker</code>를 만들고, <code>LimitTracker</code>의
<code>set_value</code> 메서드를 호출한 다음, 목 객체가 예상한 메시지를 가지고
있는지 검사할 수 있겠습니다. 예제 15-21이 바로 이런 일을 하기 위한
목 객체 구현 시도이지만, 대여 검사기가 이를 허용하지 않을 것입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
<p><span class="caption">예제 15-21: 대여 검사기가 허용하지 않는
<code>MockMessenger</code> 구현 시도</span></p>
<p>이 테스트 코드는 보냈다고 알려주는 메시지를 추적하기 위한 <code>String</code>
값의 <code>Vec</code>인 <code>sent_messages</code> 필드를 갖는 <code>MockMessenger</code> 구조체를
정의합니다. 또한 연관 함수 <code>new</code>를 정의하여 편리하게 빈 메시지 리스트로
시작하는 새로운 <code>MockMessenger</code> 값을 생성할 수 있도록 합니다.
그런 다음에는 <code>MockMessenger</code>에 대한 <code>Messenger</code> 트레이트를 구현하여
<code>MockMessenger</code>를 <code>LimitTracker</code>에 넘겨줄 수 있도록 하였습니다.
<code>send</code> 메서드의 정의 부분에서는 매개변수로 넘겨진 메시지를 가져와서
<code>MockMessenger</code> 내의 <code>sent_messages</code> 리스트에 저장합니다.</p>
<p>테스트 내에서는 <code>LimitTracker</code>의 <code>value</code>에 <code>max</code> 값의 75퍼센트 이상인
어떤 값이 설정되었다 했을 때 무슨 일이 일어나는지 테스트하고 있습니다. 먼저
새로운 <code>MockMessenger</code>를 만드는데, 이는 빈 메시지 리스트로 시작될 것입니다.
그 다음 새로운 <code>LimitTracker</code>를 만들고 여기에 새로운 <code>MockMessenger</code>의
참조자와 <code>max</code> 값 100을 매개변수로 넘깁니다. <code>LimitTracker</code>의 <code>set_value</code>
메서드를 80 값으로 호출하였는데, 이는 75퍼센트 이상입니다. 그다음
<code>MockMessenger</code>가 추적하고 있는 메시지 리스트가 이제 한 개의 메시지를
가지고 있는지를 검사합니다.</p>
<p>하지만, 이 테스트에는 아래와 같이 한 가지 문제점이 있습니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn send(&amp;self, msg: &amp;str);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
</code></pre>
<p>메시지를 추적하기 위해서 <code>MockMessenger</code>를 수정할 수가 없는데, 그 이유는
<code>send</code> 메서드가 <code>self</code>의 불변 참조자를 가져오기 때문입니다. 또한 에러
메시지가 제안하는 <code>&amp;mut self</code>를 대신 사용하라는 것도 받아들일 수 없는데, 그렇게
되면 <code>send</code>의 시그니처가 <code>Messenger</code> 트레이트의 정의에 있는 시그니처와 맞지
않게 될 것이기 때문입니다. (편하게 한번 시도해 보고 어떤 에러가 나오는지 보세요.)</p>
<p>지금이 내부 가변성의 도움을 받을 수 있는 상황입니다! <code>sent_messages</code>가
<code>RefCell&lt;T&gt;</code> 내에 저장되게 하면, <code>send</code> 메서드는 <code>sent_message</code>를
수정하여 우리에게 보이는 메시지를 저장할 수 있게 될 것입니다. 예제 15-22는
이것이 어떤 형태인지를 보여줍니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --생략--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
<p><span class="caption">예제 15-22: <code>RefCell&lt;T&gt;</code>를 사용하여 바깥쪽에서는
불변으로 간주되는 한편 내부 값 변경하기</span></p>
<p><code>sent_message</code> 필드는 이제 <code>Vec&lt;String&gt;</code> 대신 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
타입입니다. <code>new</code> 함수에서는 빈 벡터를 감싼 새로운 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
인스턴스를 생성합니다.</p>
<p><code>send</code> 메서드의 구현부에서 첫 번째 매개변수는 여전히 <code>self</code>의 불변 대여
형태인데, 이는 트레이트의 정의와 일치합니다. <code>self.sent_messages</code>의
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>에 있는 <code>borrow_mut</code>를 호출하여 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
내부 값, 즉 벡터에 대한 가변 참조자를 얻습니다. 그런 다음에는 그 벡터에 대한
가변 참조자의 <code>push</code>를 호출하여 테스트하는 동안 보내진 메시지를 추적할
수 있습니다.</p>
<p>변경할 필요가 있는 마지막 부분은 단언 부분 안에 있습니다: 내부 벡터 안에
몇 개의 아이템이 있는지 보기 위해서 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>의 <code>borrow</code>를
호출하여 벡터에 대한 불변 참조자를 얻습니다.</p>
<p>이제 <code>RefCell&lt;T&gt;</code>가 어떻게 동작하는지 보았으니, 어떻게 동작하는지 파봅시다!</p>
<h4 id="refcellt로-런타임에-대여-추적하기"><a class="header" href="#refcellt로-런타임에-대여-추적하기"><code>RefCell&lt;T&gt;</code>로 런타임에 대여 추적하기</a></h4>
<p>불변 및 가변 참조자를 만들 때는 각각 <code>&amp;</code> 및 <code>&amp;mut</code> 문법을 사용합니다.
<code>RefCell&lt;T&gt;</code>로는 <code>borrow</code>와 <code>borrow_mut</code> 메서드를 사용하는데,
이들은 <code>RefCell&lt;T&gt;</code>가 보유한 안전한 API 중 일부입니다. <code>borrow</code> 메서드는
스마트 포인터 타입인 <code>Ref&lt;T&gt;</code>를 반환하고, <code>borrow_mut</code>는 스마트 포인터
타입 <code>RefMut&lt;T&gt;</code>를 반환합니다. 두 타입 모두 <code>Deref</code>를 구현하였기 때문에,
이들을 보통의 참조자처럼 다룰 수 있습니다.</p>
<p><code>RefCell&lt;T&gt;</code>는 현재 활성화된 <code>Ref&lt;T&gt;</code>와 <code>RefMut&lt;T&gt;</code> 스마트 포인터들이
몇 개나 있는지 추적합니다. <code>borrow</code>를 호출할 때마다, <code>RefCell&lt;T&gt;</code>는
불변 참조자가 활성화된 개수를 증가시킵니다. <code>Ref&lt;T&gt;</code> 값이 스코프 밖으로 벗어날
때는 불변 대여의 개수가 하나 감소합니다. 컴파일 타임에서의 대여 규칙과 똑같이,
<code>RefCell&lt;T&gt;</code>는 어떤 시점에서든 여러 개의 불변 대여 혹은 하나의 가변 대여를
가질 수 있도록 만들어 줍니다.</p>
<p>만일 이 규칙들을 위반한다면, <code>RefCell&lt;T&gt;</code>의 구현체는 참조자에 대해 그렇게
했을 때처럼 컴파일 에러를 내는 것이 아니라, 런타임에 <code>panic!</code>을 일으킬
것입니다. 예제 15-23은 예제 15-22의 <code>send</code> 구현을 수정한
것입니다. 고의로 같은 스코프에서 두 개의 가변 대여를 만드는 시도를 하여
<code>RefCell&lt;T&gt;</code>가 이렇게 하는 것을 런타임에 방지한다는 것을 보여주고
있습니다.</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><span class="caption">예제 15-23: 두 개의 가변 참조자를 같은 스코프에서
만들어서 <code>RefCell&lt;T&gt;</code>이 패닉을 일으키는 것을 보기</span></p>
<p><code>borrow_mut</code>로부터 반환되는 <code>RefMut&lt;T&gt;</code> 스마트 포인터를 위한 <code>one_borrow</code>
변수가 만들어졌습니다. 그런 다음 또 다른 가변 대여를 같은 방식으로 <code>two_borrow</code> 변수에
만들어 넣었습니다. 이는 같은 스코프에 두 개의 가변 참조자를 만드는 것이고, 허용되지
않습니다. 라이브러리를 위한 테스트를 실행하면 예제 15-23의 코드는 어떠한
에러 없이 컴파일되겠지만, 테스트는 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 코드가 <code>already borrowed: BorrowMutError</code>라는 메시지와 함께 패닉을
일으켰음을 주목하세요. 이것이 바로 <code>RefCell&lt;T&gt;</code>가 런타임에 대여 규칙 위반을
다루는 방법입니다.</p>
<p>여기서처럼 대여 에러를 컴파일 타임이 아닌 런타임에 잡기로 선택하는
것은 개발 과정 이후에 여러분의 코드에서 실수를 발견할 가능성이 있음을
의미합니다: 여러분의 코드가 프로덕션으로 배포될 때까지 발견되지 않을
수도 있습니다. 또한, 여러분의 코드는 컴파일 타임이 아닌 런타임에 대여를
추적하는 결과로 약간의 런타임 성능 페널티를 초래할 것입니다.
하지만 <code>RefCell&lt;T&gt;</code>를 이용하는 것은 오직 불변값만 허용된 컨텍스트 안에서
사용하는 중에 본 메시지를 추적하기 위해서 스스로를 변경할 수 있는 목 객체
작성을 가능하게 해 줍니다. 트레이드오프가 있더라도 <code>RefCell&lt;T&gt;</code>를
사용하여 일반적인 참조자가 제공하는 것보다 더 많은 기능을 얻을 수
있습니다.</p>
<h3 id="rct와-refcellt를-조합하여-가변-데이터의-복수-소유자-만들기"><a class="header" href="#rct와-refcellt를-조합하여-가변-데이터의-복수-소유자-만들기"><code>Rc&lt;T&gt;</code>와 <code>RefCell&lt;T&gt;</code>를 조합하여 가변 데이터의 복수 소유자 만들기</a></h3>
<p><code>RefCell&lt;T&gt;</code>를 사용하는 일반적인 방법은 <code>Rc&lt;T&gt;</code>와 조합하는 것입니다. <code>Rc&lt;T&gt;</code>가
어떤 데이터에 대해 복수의 소유자를 허용하지만, 그 데이터에 대한 불변 접근만 제공하는
것을 상기하세요. 만일 <code>RefCell&lt;T&gt;</code>를 들고 있는 <code>Rc&lt;T&gt;</code>를 가지게 되면,
가변이면서 <em>동시에</em> 복수의 소유자를 갖는 값을 얻을 수 있는 것이죠!</p>
<p>예를 들면, 예제 15-18에서 <code>Rc&lt;T&gt;</code>를 사용하여 여러 개의 리스트가
어떤 리스트의 소유권을 공유하도록 해준 콘스 리스트 예제를 상기해 보세요.
<code>Rc&lt;T&gt;</code>가 오직 불변의 값만을 가질 수 있기 때문에, 일단 이것들을 만들면
리스트 안의 값들을 변경하는 것은 불가능했습니다. <code>RefCell&lt;T&gt;</code>를 추가하여
이 리스트 안의 값을 변경하는 능력을 얻어봅시다. 예제 15-24는 <code>Cons</code> 정의
내에 <code>RefCell&lt;T&gt;</code>를 사용하여 모든 리스트 내에 저장된 값이 변경될 수
있음을 보여줍니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}</code></pre></pre>
<p><span class="caption">예제 15-24: <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>를 사용하여
변경 가능한 <code>List</code> 생성하기</span></p>
<p>먼저 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>의 인스턴스 값을 생성하고 <code>value</code>라는 이름의 변수
안에 저장하여 나중에 이를 직접 접근할 수 있게 했습니다. 그다음 <code>value</code>를
가지고 있는 <code>Cons</code> 배리언트로 <code>List</code>를 생성하여 <code>a</code>에 넣었습니다. <code>value</code>는
클론되어 <code>value</code>가 가진 내부의 값 <code>5</code> 값에 대한 소유권이 <code>a</code>로 이동되거나
<code>a</code>가 <code>value</code>로부터 빌려오는 것이 아니라 <code>a</code>와 <code>value</code> 모두가 이 값에 대한
소유권을 갖도록 할 필요가 있습니다.</p>
<p>리스트 <code>a</code>는 <code>Rc&lt;T&gt;</code>로 감싸져서, <code>b</code>와 <code>c</code> 리스트를 만들 때는 둘 다 <code>a</code>를
참조할 수 있는데, 이는 예제 15-18에서 해본 것입니다.</p>
<p><code>a</code>, <code>b</code>와 <code>c</code> 리스트가 생성된 이후, <code>value</code>의 값에 10을 더하려고
합니다. 이는 <code>value</code>의 <code>borrow_mut</code>를 호출하는 식으로 수행되었는데,
여기서 5장에서 논의했던 자동 역참조 기능이 사용되어 <code>Rc&lt;T&gt;</code>를
역참조하여 안에 있는 <code>RefCell&lt;T&gt;</code> 값을 얻어옵니다
(<a href="ch05-03-method-syntax.html#wheres-the---operator">‘<code>-&gt;</code> 연산자는 없나요?’</a><!-- ignore -->절을 보세요).
<code>borrow_mut</code> 메서드는 <code>RefMut&lt;T&gt;</code> 스마트 포인터를 반환하고, 여기에 역참조
연산자를 사용한 다음 내부 값을 변경합니다.</p>
<p><code>a</code>, <code>b</code>와 <code>c</code>를 출력하면 이 리스트들이 모두 5가 아니라 변경된 값
15를 가지고 있는 것을 볼 수 있습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>이 기술은 꽤 근사합니다! <code>RefCell&lt;T&gt;</code>를 이용하면 표면상으로는 불변인
<code>List</code>를 갖게 됩니다. 하지만 데이터를 변경할 필요가 생기면 내부 가변성 접근
기능을 제공하는 <code>RefCell&lt;T&gt;</code>의 메서드를 사용하여 그렇게 할 수 있습니다.
대여 규칙의 런타임 검사는 데이터 경합으로부터 우리를 지켜주고, 데이터 구조에
대한 이런 유연성을 위해서 약간의 속도를 맞바꾸는 것이 때로는 가치가 있습니다.
<code>RefCell&lt;T&gt;</code>가 멀티스레드 코드에서는 동작하지 않음을 주의하세요!
<code>Mutex&lt;T&gt;</code>가 <code>RefCell&lt;T&gt;</code>의 스레드 안전 버전이고, 이는 16장에서
다루겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
